<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="/assets/css/style.css" />
    <title>blog</title>
    <link type="application/atom+xml" rel="alternate" href="ajeetsinghparmar.github.io/feed.xml" />
    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>blog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="blog" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="ajeetsinghparmar.github.io/blog.html" />
<meta property="og:url" content="ajeetsinghparmar.github.io/blog.html" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="blog" />
<script type="application/ld+json">
{"@type":"WebPage","url":"ajeetsinghparmar.github.io/blog.html","headline":"blog","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
      <a class="navbar-brand" href="index.html">SB</a>
      <button
        class="navbar-toggler"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#navbarNav"
        aria-controls="navbarNav"
        aria-expanded="false"
        aria-label="Toggle navigation"
      >
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav">
            
          <li class="nav-item">
            <a aria-current="page" href="/" class="nav-link">Home</a>
          </li>
          
          <li class="nav-item">
            <a aria-current="page" href="/about.html" class="nav-link">About</a>
          </li>
          
          <li class="nav-item">
            <a aria-current="page" href="/blog.html" class="nav-link active">Blog</a>
          </li>
          
          <li class="nav-item">
            <a aria-current="page" href="/staff.html" class="nav-link">Staff</a>
          </li>
          
        </ul>
      </div>
    </div>
  </nav>


<h1>Latest Posts</h1>

<ul>
    
    <li>
        <h2><a href="/2021/01/09/python_notes.html">Python Notes Complete</a></h2>
        <!-- <p><br />
    <span style="color: teal"><em>The Book of Python Notes</em></span><br />
    <br />
    </p>
    <p><img src="/assets/img/logo.jpg" alt="image" style="width:2in" /></p>
    <p><span><span class="smallcaps">BY</span></span><br />
    </p>
    <p><span><strong>AJEET SINGH PARMAR</strong></span><br />
    </p>
    <div id="Contents">
    
    </div>
    <h1 id="basics-of-python">Basics of Python</h1>
    <h2 id="why-python-for-data-science">Why Python for Data Science?</h2>
    <p>Python was created by Guide Van Rossum and first released in 1991. The name Python was inspired by the comedy series Monty Python’s Flying circus.</p>
    <h3 id="advantages-of-python">Advantages of Python:</h3>
    <p>Following are the some of major advantages of Python:</p>
    <h4 id="easy-to-learn">Easy to learn:</h4>
    <p>Python is a very beginner friendly language. The syntax (words and structure) is extremely simple to read and follow, most of which can be understood even if you do not know programming.</p>
    <h4 id="versatility">Versatility</h4>
    <p>Python is a multi-paradigm programming language. It supports object-oriented programming, structured programming, and functional programming patterns, among others. Python can handle every job ranging from data mining to website construction to running embedded systems, all in one unified language.</p>
    <h4 id="community-support">Community Support</h4>
    <p>Python’s broad and diverse base means that there are millions of users who are happy to offer advice or suggestions when you get stuck on something. Chances are, someone else has been stuck there first. Open-source communities are known for their open discussion policies. In fact, most of the queries can be solved with a simple Google Search.</p>
    <h4 id="awesome-and-free-libraries">Awesome and Free libraries</h4>
    <p>The libraries form the backbone for the success of any programming language. At present more than 140,000 projects exist in the <strong>Python Package Index (PyPI)</strong>.</p>
    <p>Data Science has been an early beneficiary of these libraries. Libraries like <strong>NumPy, Pandas</strong> and <strong>Scikit-learn</strong> are extremely popular and widely used by Data Scientists worldwide. Do you want to start doing Deep Learning? No problems! Python has libraries like <strong>Tensorflow, Pytorch</strong> and <strong>Keras</strong> to help you.</p>
    <h4 id="interpreted-language">Interpreted Language</h4>
    <p>Python is an interpreted language, not a compiled one. This statement means that the original program is translated into "something else". Another program – "the interpreter" – then examines "something else" and performs whatever actions are called for.</p>
    <p>Besides, Python is dynamically typed, i.e., we don’t need to define variable data type ahead of time; Python automatically guesses the data type of the variable based on the type of value it contains.</p>
    <h2 id="variables-and-statement">Variables and Statement</h2>
    <h3 id="what-are-variables">What are Variables</h3>
    <p>Variables are used to store values in memory. We can store integers, decimals, characters, words or sentences in a variable. In order to assign value to a variable, use the equal(=) sign.</p>
    <p><span>Example</span></p>
    <pre><code>x = 1  
    y = 2.0
    name =  &quot;Paul&quot;
    </code></pre>
    <p>Here, 1, 2.0, and "Paul" are assigned to the variables x, y, and name respectively.</p>
    <h3 id="data-types-in-python">Data Types in Python</h3>
    <p>Python has five standard data types, listed as follows:</p>
    <ol>
    <li><p>Boolean</p></li>
    <li><p>Numbers</p></li>
    <li><p>String</p></li>
    <li><p>List</p></li>
    <li><p>Dictionary</p></li>
    <li><p>Tuple</p></li>
    </ol>
    <h4 id="boolean">Boolean</h4>
    <p>Boolean is nothing but True (1) and False (0) statements. Their sole purpose is to evaluate conditions.</p>
    <p>For example: Is 2 &lt; 3? Yes, so it will return a value 1.</p>
    <p>Is ’abc’ equal to ’abc’ (written as ’abc’ == ’abc’? Yes, again.</p>
    <p>We will take look at the other data types in upcoming topics</p>
    <h2 id="how-to-use-the-print-function">How to use the <code>print()</code> function</h2>
    <p>The <code>print()</code> function is used to display the variable’s result.</p>
    <p>The syntax is:</p>
    <p><code>print(*objects, sep=’ ’, end=’\n’, file=sys.stdout, flush=False) </code></p>
    <p>Here,</p>
    <ol>
    <li><p>objects is/are the values to be displayed</p></li>
    <li><p>sep is the separator used between the values (defaults into a space character)</p></li>
    <li><p>After all, values are printed, end is printed (defaults into a new line)</p></li>
    <li><p>file is the object where the values are printed (default value is sys.stdout i.e. screen)</p></li>
    </ol>
    <p><span>Example of <code>print()</code> function</span></p>
    <pre><code>x = 1
    print(x)</code></pre>
    <p><span>Output</span> 1</p>
    <h2 id="determining-the-type-of-object-with-type">Determining the Type of Object with <code>type()</code></h2>
    <p>If you are confused about what class an object belongs to simply use the type() function. In the example given above, the types of the variables are int, float and str respectively.</p>
    <p><span>Example</span> print(type(x))</p>
    <p><span>Output</span> int</p>
    <h2 id="checking-instance-type-with-isinstance">Checking Instance Type with <code>isinstance()</code></h2>
    <p>The <code>isinstance()</code> function checks if the object (first argument) is an instance or a subclass of classinfo (second argument).</p>
    <p>Its syntax is: <code>isinstance(object, classinfo)</code></p>
    <p>It returns <code>True </code>if the object is an instance or subclass of a class or any element of the tuple <code>False</code> otherwise.</p>
    <p><span>Example</span> isinstance(x, int)</p>
    <p><span>Output</span> True</p>
    <p><span>Creating Variables</span></p>
    <pre><code>type(age) == int
    age == 12
    type(name) == str
    name == &quot;John&quot;
    # Code starts here
    
    # Assign variable names
    age = 12
    name = &#39;John&#39;
    
    # Check types
    type_name=type(name)
    type_age=type(age)
    
    # print out types
    print(type_name)
    print(type_age)
    
    # Code ends here
    </code></pre>
    <h2 id="numbers">Numbers</h2>
    <h3 id="numeric-types">Numeric Types</h3>
    <p>It is used to store numeric values. For example: x=5x=5, y = 10y=10, balance = 15,000 balance=15,000 etc.</p>
    <p>Python supports three different types of numbers, listed as follows:</p>
    <ol>
    <li><p>Int (integers)</p></li>
    <li><p>Float (decimal numbers)</p></li>
    <li><p>Complex (complex numbers)</p></li>
    </ol>
    <dl>
    <dt>Integers</dt>
    <dd><p>are positive or negative whole numbers with no decimal point. For example: 2and 4 are integers.</p>
    </dd>
    <dt>Floats</dt>
    <dd><p>are numbers containing a decimal point (.).</p>
    <p>For example: 2.3</p>
    <p>Note that numbers written in a scientific notation such as <span class="math inline">\(2.5*10^5\)</span> are a float number because it contains a decimal point in the notation.</p>
    </dd>
    <dt>Complex</dt>
    <dd><p>Python also provides support for complex numbers of the form <span class="math inline">\(a + bJ\)</span>, where <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are floats and <span class="math inline">\(J\)</span>’s value is the square root of minus 1. Its real part is a and the imaginary part is b.</p>
    </dd>
    </dl>
    <h3 id="common-numeric-operations">Common Numeric Operations</h3>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;"><strong>Symbol</strong></th>
    <th style="text-align: left;"><strong>Function</strong></th>
    <th style="text-align: left;"><strong>Example</strong></th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">+</td>
    <td style="text-align: left;">Addition</td>
    <td style="text-align: left;">2+3 returns 5</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">-</td>
    <td style="text-align: left;">Subtraction</td>
    <td style="text-align: left;">2-3 returns -1</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">*</td>
    <td style="text-align: left;">Multiplication</td>
    <td style="text-align: left;">2*3 returns 6</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">//</td>
    <td style="text-align: left;">Integer Division</td>
    <td style="text-align: left;">3//2 returns 1</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">/</td>
    <td style="text-align: left;">Division</td>
    <td style="text-align: left;">3/2 returns 1.5</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">**</td>
    <td style="text-align: left;">Exponentiation</td>
    <td style="text-align: left;">2**3 returns 8</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">abs()</td>
    <td style="text-align: left;">Absolute value</td>
    <td style="text-align: left;">abs(-2) returns 2</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">math.exp()</td>
    <td style="text-align: left;">e raised to power</td>
    <td style="text-align: left;">math.exp(2) returns 7.38905609893065</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">math.log()</td>
    <td style="text-align: left;">Logarithm with base e</td>
    <td style="text-align: left;">math.log(2) returns 0.69314718055599453</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">math.log10()</td>
    <td style="text-align: left;">Logarithm with base 10</td>
    <td style="text-align: left;">math.log10(2) returns 0.3010299956639182</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">pow()</td>
    <td style="text-align: left;">first argument to the power of second</td>
    <td style="text-align: left;">pow(2,3) returns 8</td>
    </tr>
    </tbody>
    </table>
    <p><span>Note</span> Functions with prefix math requires the import of math module.</p>
    <h2 id="type-conversion">Type Conversion</h2>
    <p>During data manipulation, there might arise a need for converting an integer to float, float to an integer, float to a string, or splitting on a decimal point in a float. Let’s look at how you can do this.</p>
    <p>Let’s say you have the number x. The following are some common operations:</p>
    <dl>
    <dt><code>int(x)</code></dt>
    <dd><p>converts <code>x</code> to integer</p>
    </dd>
    <dt><code>float(x)</code></dt>
    <dd><p>converts <code>x</code> to float</p>
    </dd>
    <dt><code>complex(x)</code></dt>
    <dd><p>converts <code>x</code> to a complex number with real part <code>x</code> and imaginary part 0</p>
    </dd>
    </dl>
    <h5 id="calculate-the-compound-interest">Calculate the Compound Interest</h5>
    <p>In this problem, you will calculate the compound interest (C.I.). Remember that the formula for compound interest for the amount after n years is <span class="math display">\[A = P\left(1 + \frac{r}{100}\right)^n\]</span></p>
    <p>Here, A is the Amount after n years, r is the rate of interest, and P is the principal. Your task is to calculate the amount after two years on a principal amount of USD 1000 at the rate of 10 % p.a.</p>
    <p><span>Solution Code</span></p>
    <pre><code># Code starts here
    
    # store variable names
    P=1000
    r=10
    n=2
    
    # compound interest formula
    A=P*(1+10/100)**2
    
    # display compound interest
    
    print(A)
    # display interest
    interest=A-P
    print(interest)
    # Code ends here
    </code></pre>
    <h2 id="string">String</h2>
    <p>Strings can be written in three ways:</p>
    <ul>
    <li><p>Single quotes.</p>
    <p>Example:</p>
    <p><code>name = ‘Ajeet’</code></p></li>
    <li><p>Double quotes</p>
    <p>Example:</p>
    <p><code>name = “Ajeet”</code></p></li>
    <li><p>Triple quotes: They are used as multi line comment and also used to make docstrings of a defined function.</p>
    <p>Example:</p>
    <p><code>“‘This is a function. Do not change it, or else it will not work.’”</code></p></li>
    </ul>
    <p>We can use Python’s built in len() function to find the length of string.</p>
    <h3 id="slicing-and-indexing-of-strings">Slicing and Indexing of Strings</h3>
    <p>Indexing means giving every character of string a unique value. Indexing in Python starts from zero, that means first letter of string has a value zero (not 1). All the iterables (String, dictionaries, tuples, sets) have this property.</p>
    <table>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">0</td>
    <td style="text-align: center;">1</td>
    <td style="text-align: center;">2</td>
    <td style="text-align: center;">3</td>
    <td style="text-align: center;">4</td>
    <td style="text-align: center;">5</td>
    <td style="text-align: center;">6</td>
    <td style="text-align: center;">7</td>
    <td style="text-align: center;">8</td>
    <td style="text-align: center;">9</td>
    <td style="text-align: center;">10</td>
    <td style="text-align: center;">11</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">M</td>
    <td style="text-align: center;">O</td>
    <td style="text-align: center;">N</td>
    <td style="text-align: center;">T</td>
    <td style="text-align: center;">Y</td>
    <td style="text-align: center;"></td>
    <td style="text-align: center;">P</td>
    <td style="text-align: center;">Y</td>
    <td style="text-align: center;">T</td>
    <td style="text-align: center;">H</td>
    <td style="text-align: center;">O</td>
    <td style="text-align: center;">N</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">-12</td>
    <td style="text-align: center;">-11</td>
    <td style="text-align: center;">-10</td>
    <td style="text-align: center;">-9</td>
    <td style="text-align: center;">-8</td>
    <td style="text-align: center;">-7</td>
    <td style="text-align: center;">-6</td>
    <td style="text-align: center;">-5</td>
    <td style="text-align: center;">-4</td>
    <td style="text-align: center;">-4</td>
    <td style="text-align: center;">-3</td>
    <td style="text-align: center;">-1</td>
    </tr>
    </tbody>
    </table>
    <p>In the above image, for the string “Monty Python”, the following points can be noticed.</p>
    <ul>
    <li><p>From left to right, index goes from 0 to (length of string - 1).</p></li>
    <li><p>From right to left, index goes from -(length of string) to -1.</p></li>
    <li><p>Ommiting term before or after the colon (:) means including everything from starting or till the end, respectively.</p></li>
    </ul>
    <p>The syntex for slicing in Python, in general, is <strong>[Start index(included):Stop index(excluded)]</strong></p>
    <p>In the above example:</p>
    <p>if we assign variable</p>
    <p>name = “Monty Python”</p>
    <p>then:</p>
    <ul>
    <li><p><code>name[6:10]</code> returns <code>Pyth</code></p></li>
    <li><p><code>name[-12:-7]</code> returns <code>Monty</code></p></li>
    <li><p><code>name[:4]</code> returns <code>Monty</code></p></li>
    <li><p><code>name[6:]</code> returns <code>Python</code></p></li>
    <li><p><code>name[:]</code> returns <code>Monty Python</code></p></li>
    <li><p><code>name[-6:9]</code> returns <code>Pyt</code></p></li>
    </ul>
    <h1 id="tuple-and-operators">Tuple and Operators</h1>
    <h2 id="creating-a-tuple">Creating a Tuple</h2>
    <p>Tuples are another type similar to lists. They store values of any type separated by commas. But how do they differ from lists?</p>
    <ul>
    <li><p>Firstly, they start and end with parenthesis ().</p>
    <p>For example</p>
    <p><code>(1,2,3,4)</code></p></li>
    <li><p>But the main difference that <strong>unlike lists, tuples are immutable i.e., they cannot be updated/changed</strong>. You can think of them as <strong>read only lists</strong>.</p></li>
    </ul>
    <p>As discussed above, it should begin and end with parenthesis.</p>
    <p>Takin the same example of weights from our discussion on lists</p>
    <p><code>scores = (80,90,95,100)</code> The only difference is that we cannot change the values inside it.</p>
    <h3 id="common-tuple-operations">Common tuple operations</h3>
    <p>Let us take two tuples a = (1,2) and b = (3,4) for this purpose</p>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;">Expession</th>
    <th style="text-align: center;">Description</th>
    <th style="text-align: center;">Example</th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">len(a)</td>
    <td style="text-align: center;">Length of tuple</td>
    <td style="text-align: center;">2</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">a + b</td>
    <td style="text-align: center;">Concatenation</td>
    <td style="text-align: center;">(1,2,3,4)</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">a*4</td>
    <td style="text-align: center;">Repitition</td>
    <td style="text-align: center;">(1,2,1,2,1,2,1,2)</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">2 in a</td>
    <td style="text-align: center;">Membership</td>
    <td style="text-align: center;">True</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">max(a)</td>
    <td style="text-align: center;">Maximum value in tuple</td>
    <td style="text-align: center;">2</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">min(a)</td>
    <td style="text-align: center;">Minimum value in tuple</td>
    <td style="text-align: center;">1</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">a[0]</td>
    <td style="text-align: center;">Indexing</td>
    <td style="text-align: center;">1</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">a[:2]</td>
    <td style="text-align: center;">Slicing</td>
    <td style="text-align: center;">(1,2)</td>
    </tr>
    </tbody>
    </table>
    <p>We cannot delete an element from the tuple(as they are immutable), but we can delete the entire tuple.</p>
    <p><span>Example</span> # <span style="color: gray">create tuple tuple of weights</span></p>
    <p>weights = (70, 80, 45, 50)</p>
    <p># <span style="color: gray">code starts here</span></p>
    <p># <span style="color: gray">create new tuple of weights</span></p>
    <p>weights_new = (70, 80, 45,50)</p>
    <p># <span style="color: gray">calculate maximum and minimum weights</span></p>
    <p>maximum = max(weights_new)</p>
    <p>minimum = min(weights_new)</p>
    <p># <span style="color: gray">calculate sum of weights</span></p>
    <p>sum_weights = sum(weights_new)</p>
    <p>l = len(weights_new)</p>
    <p># <span style="color: gray">calculate mean</span></p>
    <p>mean_new = sum_weights/l</p>
    <p>print(maximum, minimum, sum_weights, mean_new)</p>
    <p># <span style="color: gray">code ends here</span></p>
    <h2 id="mutable-vs-immutable">Mutable vs immutable</h2>
    <h3 id="introduction">Introduction</h3>
    <p>We have been hearing about <strong>mutable</strong> and <strong>immutable</strong> all along. Simply put, objects which can be modified after creation in the same memory location are called <strong>mutable</strong> and the others which cannot, are termed <strong>immutable</strong>.</p>
    <p><strong>Immutable objects</strong>: int, float, long, complex, string, tuple, bool <strong>Mutable objects</strong>: list, dict, set, byte, array, user defined classes.</p>
    <h3 id="checking-mutability">Checking Mutability</h3>
    <p>We can check if an object is mutable by first modifying the object and then comparing its new memory location with the old memory location. We can check for memory location either by using the <code>id()</code> function, which gives us memory location of the object or with the help of <code>is</code> operator, which checks for the identity of two objects.</p>
    <p>First let’s take an integer (type <code>int</code>) 50 and add 1 to it with the same variable name, then check its memory location before and after the modification, with <code>id()</code> function. As it turns out, both have different memory locations, and hence it is an immutable type.</p>
    <p><span>Example</span> # <span style="color: gray">initial variable</span></p>
    <p>a = 50</p>
    <p># <span style="color: gray">initial memory location</span></p>
    <p>print(id(a))</p>
    <p># <span style="color: gray">modified variable</span></p>
    <p>a += 1</p>
    <p># <span style="color: gray">new memory location, is it same?</span></p>
    <p>print(id(a))</p>
    <p><span>Output</span> 94285850046496</p>
    <p>94285850046528</p>
    <p>Now let’s make a list with values [1,2,3,4] and add 5 to it with <code>.append()</code>. You observe that after modification, it still refers to the same memory location as before, and hence it is of mutable type.</p>
    <p><span>Example</span> # <span style="color: gray">initial list</span></p>
    <p>l = [1,2,3,4]</p>
    <p># <span style="color: gray">initial memory location</span></p>
    <p>print(id(l))</p>
    <p>print(’=’*20)</p>
    <p># <span style="color: gray">new list</span></p>
    <p>l.append(5)</p>
    <p>print(l)</p>
    <p>print(’=’*20)</p>
    <p># <span style="color: gray">new memory location</span></p>
    <p>print(id(l))</p>
    <p><span>Output</span> 2083508003264</p>
    <p>====================</p>
    <p>[1, 2, 3, 4, 5]</p>
    <p>====================</p>
    <p>2083508003264</p>
    <h2 id="what-are-operators">What are Operators?</h2>
    <h3 id="introduction-1">Introduction</h3>
    <p>Operators are special symbols in Python that carry out arithmatic or logical computation. The values that the operator operates on is called operand.</p>
    <p>For example,</p>
    <p>In the <code>3 + 3 = 6</code> operation, the numbers on the left-hand side of the = sign, i.e., 3 and 3 are operands while + is the operator and 6 is the output of the operation.</p>
    <h3 id="types-of-operators">Types of operators</h3>
    <p>Python supports the following types of operators —</p>
    <ul>
    <li><p>Arithmatic Operators</p></li>
    <li><p>Comparison (Relational) Operators</p></li>
    <li><p>Logical Operators</p></li>
    <li><p>Assignment Operators</p></li>
    <li><p>Bitwise Operators</p></li>
    <li><p>Membership Operators</p></li>
    <li><p>Identity Operators</p></li>
    </ul>
    <h4 id="arithmatic-operators">Arithmatic Operators</h4>
    <p><strong>Introduction</strong> Arithmetic operators include signs like +, -, *, / etc. These signs help us carry out simple mathematical operations like addition, subtraction, and multiplication.</p>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;"><strong>Operator</strong></th>
    <th style="text-align: left;"><strong>Description</strong></th>
    <th style="text-align: center;"><strong>Example</strong></th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">+(Addition)</td>
    <td style="text-align: left;">Adds values on either side of the operator</td>
    <td style="text-align: center;">2+4=6</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">-(Subtraction)</td>
    <td style="text-align: left;">Subtracts the right hand operand from left hand operand</td>
    <td style="text-align: center;">4-2=2</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">*(Multiplication)</td>
    <td style="text-align: left;">Multiplies values on either side of the operator</td>
    <td style="text-align: center;">2*4=8</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">/(Division)</td>
    <td style="text-align: left;">Divides the left hand operand by the right hand operand</td>
    <td style="text-align: center;">4/2=2.0</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">%(Modulus)</td>
    <td style="text-align: left;">Divides the left hand operand by the right hand operand and returns remainder</td>
    <td style="text-align: center;">4%2=0</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">**(Exponent)</td>
    <td style="text-align: left;">Exponential (power) calculation on operators</td>
    <td style="text-align: center;">4**2=16</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">//(Floor Division)</td>
    <td style="text-align: left;">Division of operands where the result is the quotient and the digits after the decimal point are removed. But if one of the operands is negative, the result is floored, i.e., rounded away from zero (towards negative infinity)</td>
    <td style="text-align: center;">9//2 = 4, -11//3 = -4</td>
    </tr>
    </tbody>
    </table>
    <p><span>Example</span></p>
    <pre><code>
    # x=15
    # y=4
    
    # Code starts here
    
    # addition
    addition=x+y
    # subtractiom
    subtraction = x-y
    # multiplication
    multiplication=x*y
    # division
    division=x/y
    # integer division
    integer_division=x//y
    # exponentiation
    exponent = x**y
    print(addition)
    print(subtraction)
    print(multiplication)
    print(division)
    print(integer_division)
    print(exponent)
    </code></pre>
    <h4 id="comparison-operators">Comparison Operators</h4>
    <p><strong>Introduction</strong></p>
    <p>Also called Relational operators, they compare the values on either side of the operand and decide the relation among them.</p>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;"><strong>Operator</strong></th>
    <th style="text-align: left;">Description</th>
    <th style="text-align: center;">Example</th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">==</td>
    <td style="text-align: left;">If the values of the two operands are equal, then the condition becomes true.</td>
    <td style="text-align: center;">4 ==4 is true</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">!=</td>
    <td style="text-align: left;">If values of the two operands are not equal, then the condition becomes true.</td>
    <td style="text-align: center;">2!=4 is true</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;"><code>&gt;</code></td>
    <td style="text-align: left;">If the value of the left operand is less than the value of the right operand, then the condition becomes false.</td>
    <td style="text-align: center;">3<code>&gt;</code>4 is false</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;"><code>&lt;</code></td>
    <td style="text-align: left;">If the value of the left operand is less than the value of the right operand, then the condition becomes true.</td>
    <td style="text-align: center;">1<code>&lt;</code>2 is true</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;"><code>&gt;=</code></td>
    <td style="text-align: left;">If the value of the left operand is less than or equal to the value of the right operand, then the condition becomes false.</td>
    <td style="text-align: center;">10 <code>&gt;= 6</code> is true</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">&lt;=</td>
    <td style="text-align: left;">If the value of the left operand is less than or equal to the value of the right operand, then the condition becomes true.</td>
    <td style="text-align: center;">10 &lt;= 6 is false</td>
    </tr>
    </tbody>
    </table>
    <p><span>Example</span></p>
    <pre><code>
    # x=10
    # y=12
    
    #Code starts here
    
    # greater than
    is_greater=x&gt;y
    # lesser than
    is_less=x&lt;y
    # equal to
    is_equal=x==y
    # greater than or equal to
    is_greater_equal=x&gt;=y
    # lesser than or equal to
    is_less_equal=x&lt;=y
    print(is_greater)
    print(is_less)
    print(is_equal)
    print(is_greater_equal)
    print(is_less_equal)
    # Code ends here
    </code></pre>
    <h4 id="logical-operators">Logical Operators</h4>
    <p><strong>Introduction</strong></p>
    <p>Logical operators are <code>and, or, not</code> operators–</p>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;"><strong>Operator</strong></th>
    <th style="text-align: left;"><strong>Description</strong></th>
    <th style="text-align: center;"><strong>Example</strong></th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;"><code>and</code>(Logical AND)</td>
    <td style="text-align: left;">If both the operands are true, then condition becomes true</td>
    <td style="text-align: center;">(True and False) is False</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;"><code>or</code>(Logical OR)</td>
    <td style="text-align: left;">If any of the two operands are non-zero then condition becomes true</td>
    <td style="text-align: center;">(True or False) is True</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;"><code>not</code>(Logical NOT)</td>
    <td style="text-align: left;">Reverse the logical state of its operand</td>
    <td style="text-align: center;">not(False) is True</td>
    </tr>
    </tbody>
    </table>
    <p><span>Example</span></p>
    <pre><code>x, y = True, False
    
    # Code starts here
    
    
    # AND operation
    x_and_y = x and y
    print(x_and_y)
    # OR operation
    x_or_y=x or y
    print(x_or_y)
    # Code ends here</code></pre>
    <h4 id="assignment-operators">Assignment Operators</h4>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;"><strong>Operator</strong></th>
    <th style="text-align: left;"><strong>Description</strong></th>
    <th style="text-align: left;"><strong>Example</strong></th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">=</td>
    <td style="text-align: left;">Assigns values from the right side operands to the left side operands</td>
    <td style="text-align: left;">x = a + b assigns value of a + b into x</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">+=</td>
    <td style="text-align: left;">Adds the right operand to the left operand and assigns the result to the left operand</td>
    <td style="text-align: left;">x += a is equivalent to x = x + a</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">-=</td>
    <td style="text-align: left;">Subtracts the right operand from the left operand and assigns the result to the left operand</td>
    <td style="text-align: left;">x -= a is equivalent to x = x - a</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">*=</td>
    <td style="text-align: left;">Multiplies the right operand with the left operand and assigns the result to the left operand</td>
    <td style="text-align: left;">x *= a is equivalent to x = x*a</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">/=</td>
    <td style="text-align: left;">Divides the left operand with the right operand and assigns the result to the left operand</td>
    <td style="text-align: left;">x /= a is equivalent to x = x / a</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">%=</td>
    <td style="text-align: left;">Takes the modulus using two operands and assigns the result to left operand</td>
    <td style="text-align: left;">x %= a is equivalent to x = x % a</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">**=</td>
    <td style="text-align: left;">Performs exponential (power) calculation on operators and assigns value to the left operand</td>
    <td style="text-align: left;">x **= a is equivalent to x = x ** a</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">//=</td>
    <td style="text-align: left;">Performs the floor division on operators and assigns value to the left operand</td>
    <td style="text-align: left;">x //= a is equivalent to x = x // a</td>
    </tr>
    </tbody>
    </table>
    <h4 id="bitwise-operators">Bitwise Operators</h4>
    <p>Bitwise operators act on operands as if they were a string of binary digits. It operates bit by bit, hence the name.</p>
    <p>For example, 2 is 10 in binary and 7 is 111.</p>
    <p>In the table below: Let x = 10 (0000 1010 in binary) and y = 4 (0000 0100 in binary)</p>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;"><strong>Operator</strong></th>
    <th style="text-align: center;"><strong>Description</strong></th>
    <th style="text-align: center;"><strong>Example</strong></th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">&amp;</td>
    <td style="text-align: center;">Bitwise AND</td>
    <td style="text-align: center;"><span class="math inline">\(x \&amp; y = 0 (00000000)\)</span></td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">|</td>
    <td style="text-align: center;">Bitwise OR</td>
    <td style="text-align: center;"><span class="math inline">\(x|y = 14(00001110)\)</span></td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;"><span class="math inline">\(\sim\)</span></td>
    <td style="text-align: center;">Bitwise NOT</td>
    <td style="text-align: center;"><span class="math inline">\(\sim x=-11(11110101)\)</span></td>
    </tr>
    <tr class="even">
    <td style="text-align: center;"><code>^</code></td>
    <td style="text-align: center;">Bitwise XOR</td>
    <td style="text-align: center;"><span class="math inline">\(x \verb|^| y = 14(00001110)\)</span></td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">&gt;&gt;</td>
    <td style="text-align: center;">Bitwise Right Shift</td>
    <td style="text-align: center;"><span class="math inline">\(x&gt;&gt;2 = 2(00000010)\)</span></td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">&lt;&lt;</td>
    <td style="text-align: center;">Bitwise left shift</td>
    <td style="text-align: center;"><span class="math inline">\(x&lt;&lt;2 = 40(00101000)\)</span></td>
    </tr>
    </tbody>
    </table>
    <h4 id="membership-operators">Membership Operators</h4>
    <p><strong>Introduction</strong></p>
    <p>Membership operators test for membership in a sequence (string, list, tuple, set and dictionary). You will learn about strings, sets, tuple, etc. in the upcoming chapters.</p>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;"><strong>Operator</strong></th>
    <th style="text-align: left;"><strong>Description</strong></th>
    <th style="text-align: left;"><strong>Example</strong></th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">in</td>
    <td style="text-align: left;">Evaluates to true if it finds a variable in the specified sequence and false otherwise</td>
    <td style="text-align: left;">x in y, here in results in a 1 if x is a member of sequence y</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">not in</td>
    <td style="text-align: left;">Evaluates to true if it does not finds a variable in the specified sequence and false otherwise</td>
    <td style="text-align: left;">x not in y, here not in results in a 1 if x is not a member of sequence y</td>
    </tr>
    </tbody>
    </table>
    <p><span>Example</span></p>
    <pre><code>
    # given variable
    name = &quot;John&quot;
    
    # Code starts here
    
    # check for memberships
    list_1 = [&quot;John&quot; , &quot;Rick&quot;]
    john= &quot;John&quot; in list_1
    print(john)
    list_2=[&quot;Hall&quot;,&quot;Rick&quot;]
    hall=&quot;John&quot; in list_2
    print(list_2)
    # Display variables
    
    # Code ends here
    
    </code></pre>
    <h4 id="identity-operators">Identity Operators</h4>
    <p><strong>Introduction</strong></p>
    <p>Identity operators compare the memory locations of two objects. You already know by now that we use the id() to check the memory location of an object. There are two Identity operators, as explained below:</p>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;"><strong>Operator</strong></th>
    <th style="text-align: left;"><strong>Description</strong></th>
    <th style="text-align: left;"><strong>Example</strong></th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">is</td>
    <td style="text-align: left;">Evaluates to true if the variables on either side of the operator point to the same object and false otherwise</td>
    <td style="text-align: left;">x is y, here is results in 1 if id(x) equals id(y)</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">is not</td>
    <td style="text-align: left;">Evaluates to false if the variables on either side of the operator point to the same object and true otherwise</td>
    <td style="text-align: left;">x is not y, here is not results in 1 if id(x) is not equal to id(y)</td>
    </tr>
    </tbody>
    </table>
    <p><strong>Example</strong></p>
    <pre><code>
    # initialize variables
    x1, y1, x2, y2, d1, d2 = 5, 5, &#39;Hello&#39;, &#39;Hello&#39;,\
                           {&#39;a&#39;:1, &#39;b&#39;:2}, {&#39;a&#39;:1, &#39;b&#39;:2}
    
    # Code starts here
    x1_is_y1 = x1 is y1
    print(x1_is_y1)
    x2_is_y2 = x2 is y2
    print(x2_is_y2)
    d1_is_d2 = d1 is d2
    print(d1_is_d2)
    # Code ends here
    
    </code></pre>
    <h1 id="file-handeling">File Handeling</h1>
    <h2 id="file-operations">File Operations</h2>
    <p>In data manipulation and analysis, you will often come across reading and writing files. Python can handle files of different types including txt, JSON, HTML, CSV etc.</p>
    <p>Let’s look at the pipeline to handle file operations:</p>
    <h5 id="step-1-open-the-file">Step 1: Open the file</h5>
    <p>Lets say that you have a text file named <code>months.txt</code>. How to open this file? We use the <code>open()</code> function to open files and its syntax is given below:</p>
    <p><code> open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) </code></p>
    <p>For now, let’s focus only on the <code>path</code> and <code>mode</code> arguments.</p>
    <p>You can open the file passing the path argument to the open() function. Here, <code>file</code> is the file path of the file <code>months.txt</code>.</p>
    <p>Now you may want to use the file plainly for reading but in some cases, you may want to modify it also. For this purpose, use the argument <code>mode</code> to chose how you want to treat the file object. Below are some of the mode options:</p>
    <ul>
    <li><p>’r’ : Opens a file for reading only. The file pointer is placed at the beginning of the file. This is the default mode.</p></li>
    <li><p>’rb’: Opens a file for reading only in binary format. The file pointer is placed at the beginning of the file. This is the default mode.</p></li>
    <li><p>’rb+’: Opens a file for both reading and writing in binary format. The file pointer will be at the beginning of the file.</p></li>
    <li><p>’r+’ : Opens a file for both reading and writing. The file pointer will be at the beginning of the file.</p></li>
    <li><p>’w’ : Opens a file for writing only. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.</p></li>
    <li><p>’wb’: Opens a file for writing only in binary format. Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.</p></li>
    <li><p>’w+’: Opens a file for both writing and reading. Overwrites the existing file if the file exists. If the file does not exist, it creates a new file for reading and writing.</p></li>
    <li><p>’wb+’: Opens a file for both writing and reading in binary format. Overwrites the existing file if the file exists. If the file does not exist, it creates a new file for reading and writing.</p></li>
    <li><p>’a’: Opens a file for appending. The file pointer is at the end of the file if the file exists. That is, the file is in the append mode. If the file does not exist, it creates a new file for writing.</p></li>
    <li><p>’a+’ : Opens a file for both appending and reading. The file pointer is at the end of the file if the file exists. The file opens in the append mode. If the file does not exist, it creates a new file for reading and writing.</p></li>
    <li><p>’ab’: Opens a file for appending in binary format. The file pointer is at the end of the file if the file exists. That is, the file is in the append mode. If the file does not exist, it creates a new file for writing.</p></li>
    <li><p>’ab+’: Opens a file for both appending and reading in binary format. The file pointer is at the end of the file if the file exists. The file opens in the append mode. If the file does not exist, it creates a new file for reading and writing.</p></li>
    </ul>
    <h5 id="step-2-read-the-file">Step 2: Read the file</h5>
    <p>In this step, you read the contents of the file. It can be done in several ways:</p>
    <ol>
    <li><p>&lt;file&gt;.read(): It returns the entire content of the file as a single string.</p></li>
    <li><p>&lt;file&gt;.readline(): It returns the next line of the file, returning the text up to and including the next newline character. Simply put, this operation will read a file line-by-line.</p></li>
    <li><p>&lt;file&gt;.readlines(): It returns a list of the lines in the file, where each item of the list represents a single line.</p></li>
    </ol>
    <h5 id="step-3-write-to-a-file">Step 3: Write to a file</h5>
    <p>To write to a file use <code>&lt;file&gt;.write()</code>. The <code>write()</code> method does not add a newline character (<code>\n</code>) to the end of the string.</p>
    <h5 id="step-4-close-the-file">Step 4: Close the file</h5>
    <p>Although Python automatically closes a file when the object reference changes, it is considered a good practice to close the file. It keeps our data safe by restricting access to any other running programs.</p>
    <p>It is done with the help of the <code>&lt;file&gt;.close()</code> method.</p>
    <p><span>Example</span></p>
    <pre><code>
    # filepath is already given to you
    filepath = text_file
    # Code starts here
    # open file in read mode
    file = open(filepath,&#39;r&#39;)
    # iterate over the file object
    for line in file.readlines():
        print(line)    
    # close the file
    file.close()
    # open file in write mode
    file = open(filepath,&#39;a+&#39;)
    # write to the file
    file.write(&#39;Successfully written to the text file.&#39;)
    # close the file
    file.close()
    # Code ends here
    
    # Caution : do not delete this code
    file = open(filepath,&#39;r&#39;)
    lines=[]
    for line in file.readlines():
        lines.append(line)
    file.close()
    </code></pre>
    <h3 id="what-are-errors">What are errors?</h3>
    <p><strong>Introduction</strong></p>
    <p>Before we start discussing exceptions it is important to understand what errors are. In simple words, errors are mistakes in the code that Python doesn’t like and will result in the abrupt termination of the program. Now errors are of two types:</p>
    <h4 id="syntax-error">Syntax Error</h4>
    <p>As the name itself suggests they happen due to incorrect syntax of our code. Remember that syntax errors occur at compile time.</p>
    <p>An example indicating such an error is shown in the image below where we forget to put : after initiating the <code>while</code> loop:</p>
    <p><span>Example</span></p>
    <pre><code>while True print(&#39;Hello world&#39;)
    
    File &quot;&lt;ipython-input-4-2b688bc740d7&gt;&quot;, line 1
        while True print(&#39;Hello world&#39;)
                       ^
    SyntaxError: invalid syntax
    </code></pre>
    <p>They also are known as parsing errors and are the most common kind of complaint you get while you are still learning Python. Also, they are easy to fix as Python will show you the line number where the error is, with an error message which will be self-explanatory.</p>
    <h4 id="exceptions">Exceptions</h4>
    <p>An exception is a Python object that represents an error. If the normal flow of the program gets disrupted in spite of being syntactically correct, Python raises an exception; which if not handled properly, the program will terminate.</p>
    <p>An example of an exception is shown below where it shows us IndexError when we try to access an index which is not within the dimensions of the list array:</p>
    <p><span>Output</span></p>
    <pre><code>
    ---------------------------------------------------------
    IndexError              Traceback (most recent call last)
     &lt;ipython-input-3-2543d2a0e9f4&gt; in &lt;module&gt;()
          1 
          2 array= [1,2,3,4]
    ----&gt; 3 print(array[4])
    
     IndexError: list index out of range
    </code></pre>
    <h4 id="raising-exceptions">Raising Exceptions</h4>
    <p>Now let us understand how to raise an exception. In general, an exception instance can be raised with the raise statement. When an exception is raised, no further statements in the current block of code are executed unless the exception is handled.</p>
    <p><span>Example</span></p>
    <pre><code>
    # custom input
    num = int(input())
    
    # raise exception if input is negative
    if num &lt; 0:
        raise Exception
    else:
    # print input number if it is not negative
    print(&#39;Your number is accepted!&#39;)
    
    </code></pre>
    <p>Its outputs when we take a negative number -10 and a positive number 5 are:</p>
    <p>With -10 as input</p>
    <p><span>Output</span></p>
    <pre><code>--------------------------------------------------------
    Exception              Traceback (most recent call last)
    &lt;ipython-input-5-9029052661ca&gt; in &lt;module&gt;()
          4 # raise exception if input is negative
          5 if num &lt; 0:
    ----&gt; 6     raise Exception(&#39;{} is negative, please enter a positive number&#39;.format(num))
          7 
          8 # print input number if it is not negative
    
    Exception: -10 is negative, please enter a positive number
    </code></pre>
    <p>With 5 as input</p>
    <p><span>Output</span></p>
    <p>’Your number is accepted!’</p>
    <p><strong>Why do you need exception handling?</strong></p>
    <p>Exception handling provides a mechanism to decouple handling of errors or other exceptional circumstances from the typical control flow of your code. This allows more freedom to handle errors.</p>
    <p><strong>How does Python handle exceptions?</strong></p>
    <p>Python handles exceptions using the <code>try</code> and <code>except</code> blocks. Any code that we think might throw an error is placed inside the <code>try</code> block. If an exception is raised, control flow leaves this block immediately and goes to the <code>except</code> block which handles the corresponding exception.</p>
    <p><span>Pseudocode for exception handling</span></p>
    <pre><code>try:
        Operational/Suspicious Code
    except SomeException:
        Code to handle the exception</code></pre>
    <p><span>Example</span></p>
    <pre><code>name = &#39;Hello World!&#39;
    try:
        char = name[15]
        print(char)
    except IndexError:
        print(&#39;IndexError has been found!&#39;)
    </code></pre>
    <p><span>Output</span> ’IndexError has been found!’</p>
    <h4 id="multiple-except-statements">Multiple <code>except</code> statements</h4>
    <p>It is legal to have multiple except statements, each of which names different types of exceptions. If no exceptions are named in the except statement, it will catch all exceptions. For example:</p>
    <p><span>Example</span></p>
    <pre><code># multiple except statements
    try:
        print(45/den)
    except ValueError:
        print(&#39;caught ValueError&#39;)
    except ZeroDivisionError:
        print(&#39;caught ZeroDivisionError&#39;)</code></pre>
    <p><strong>Divide two numbers avoiding zero in the denominator</strong></p>
    <p><span>Code</span></p>
    <pre><code>try:
        quotient = num1 / num2
        message = &quot;Quotient is&quot; + &#39; &#39; + str(quotient)
        print(message)
    except ZeroDivisionError:
        message = &quot;Cannot divide by zero&quot;
        print(message)
    </code></pre>
    <h4 id="else-clause"><code>else</code> clause</h4>
    <p>The code inside else clause runs only when the exception doesn’t occur i.e. if the else block is executed, then the except block is not, and vice versa. This block is optional.</p>
    <p><span>Example using else block</span></p>
    <pre><code># try-except-else block
    try:
       print(45/12)
    except ValueError:
       print(&#39;caught ValueError&#39;)
    except ZeroDivisionError:
       print(&#39;caught ZeroDivisionError&#39;)
    else:
       print(&#39;Successfully divided&#39;)
    </code></pre>
    <p><span>Output</span></p>
    <pre><code>3.75
    &#39;Successfully divided&#39;
    </code></pre>
    <h4 id="finally-clause"><code>finally</code> clause</h4>
    <p>The code inside finally clause always executes after the other blocks, even if there was an uncaught exception or a return statement in one of the other blocks. This block is optional.</p>
    <p><span> Example using finally block</span></p>
    <pre><code>try:
       print(45/0)
    except ValueError:
       print(&#39;caught ValueError&#39;)
    except ZeroDivisionError:
       print(&#39;caught ZeroDivisionError&#39;)
    else:
       print(&#39;Successfully divided&#39;)
    finally:
       print(&#39;Every block executed!&#39;)
    </code></pre>
    <p><span>Output</span> ’Caught ZeroDivisionError’</p>
    <p>’Every block executed’</p>
    <p><strong>Some Built-in Python Exceptions</strong>– Below are some of the built-in python exceptions:</p>
    <ul>
    <li><p>Exception: The base class for all kinds of exceptions. All kind of exceptions are derived from this class</p></li>
    <li><p>ArithmeticError: Base class for the exception raised for any arithmetic errors.</p></li>
    <li><p>EOFError: Raised when input() function read End-of-File without reading any data.</p></li>
    <li><p>ZeroDivisionError: Raise when the second argument of a division or modulo operation is zero</p></li>
    <li><p>AssertionError: Raised when an assert statement fails</p></li>
    <li><p>FloatingPointError: Raised when a floating-point operation fails</p></li>
    <li><p>KeyError: Raised when a mapping (dictionary) key is not found in the set of existing keys</p></li>
    <li><p>KeyboardInterrupt: Raised when the user hits the interrupt key (normally Control-C or Delete). During execution, a check for interrupts is made regularly.</p></li>
    </ul>
    <p><strong>Divide two numbers avoiding zero in the denominator with try-except-else-finally</strong></p>
    <p><span>Code</span></p>
    <pre><code># take input
    num1, num2 = 5, 10
    # Code starts here
    # try except block
    try:
        quotient = num1/num2
        message = &quot;quotient is&quot; + &#39; &#39; + str(quotient)
        print(message)
    except ZeroDivisionError:
        message = &quot;Cannot divide by zero&quot;
        print(message)
    else:
        new_message = &quot;No exceptions occured&quot;
        print(new_message)
    finally:
        final_message = &quot;Execution Completed&quot; 
        print(final_message)       
    
    # Code ends here
    </code></pre>
    <p><strong>What is a function and why are they important?</strong></p>
    <p>A function is a block of code that is meant to perform a single, relatable task. During problem-solving, it becomes necessary to break a problem into smaller tasks; functions do just that. It makes our code more readable and modular. It also avoids repetition and makes code reusable.</p>
    <p>Python provides a lot of in-built functions like len(), print() etc. Like any other programming language, Python also provides support to create customized functions also called user-defined functions.</p>
    <h2 id="creating-functions">Creating Functions</h2>
    <p><span>Creating Function</span></p>
    <pre><code>def harmonic(n):
        total = 0.0
        for i in range(1, n+1):
            total += 1.0/n
        return total</code></pre>
    <p>In the above function, we have created the function named harmonic which calculates the harmonic mean of numbers from 1 to n. Let’s understand its anatomy. Here,</p>
    <ul>
    <li><p>Keyword def marks the start of the function header.</p></li>
    <li><p>A function name to uniquely identify it. In our example, the name is harmonic.</p></li>
    <li><p>Parameters (arguments) through which we pass values to a function. They are optional. n is our argument in our function.</p></li>
    <li><p>A colon(:)(:)to mark the end of function header.</p></li>
    <li><p>Optional documentation string (docstring) to describe what the function does.</p></li>
    <li><p>One or more valid python statements that make up the function body. The part labeled as the function body makes up this part.</p></li>
    <li><p>An optional return statement to return a value from the function. The return value is named total in the function harmonic.</p></li>
    <li><p>To call a function simply type the function name with the appropriate parameters.</p></li>
    </ul>
    <p><span>Creating Our own function</span></p>
    <pre><code># Code starts here
    def mean(n):
        sum_1 = 0
        for n in range(1,n+1):
            sum_1 +=n
        return sum_1        
            
    var_1=mean(4)
    val = var_1/4
    print(val)
    # Code ends here
    </code></pre>
    <h2 id="scoping">Scoping</h2>
    <p>How long a variable exists, depends on where it is defined. We call the part of a program where a variable is accessible its scope, and the duration for which the variable exists its lifetime. For example, parameters and variables defined inside a function is/are not visible from outside. Hence, they have a local scope. Variables declared outside a function have global scopes and they can be used throughout the program.</p>
    <p>To use a local variable as a global one, use the global keyword before the variable name. In this way, Python understands that you are using the reference of the global variable.</p>
    <p><span>Example</span></p>
    <pre><code>def f():
        # Local scope
        s = &quot;Me too.&quot;
        print(s)
    
    # Global scope
    s = &quot;It is great.&quot;
    
    print(f())
    print(s)
    </code></pre>
    <p><span>Output</span></p>
    <pre><code>&quot;Me too.&quot;
    &quot;It is great.&quot;
    </code></pre>
    <h2 id="lambda-functions">Lambda Functions</h2>
    <p>Earlier we saw that a function was created with the def keyword followed by its name. However, Python also supports the creation of anonymous functions i.e. functions without a name also called lambda functions.</p>
    <p><strong>why lambdat functions?</strong></p>
    <p>They are usually small and can have any number of arguments just like a normal function. In the image below you can see how a lambda function is created:</p>
    <p><span>Example</span></p>
    <pre><code>sumLambda = lambda x, y : x + y
    
    result = sumLambda(4, 5)
    print(result)
    </code></pre>
    <p><span>Compute square of a number using lambda functions</span></p>
    <pre><code># Code starts here
    # lambda function to calculate square
    square = lambda n : n**2
    # natural numbers list
    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    # empty list
    square_nums = []
    # loop through every element in list
    for i in nums:
        var = square(i) 
        square_nums.append(var)   
    # display new list
    print(square_nums)
    </code></pre>
    <h2 id="working-with-higher-order-functions">Working with Higher Order Functions</h2>
    <p>Higher order functions are those functions which can accept other functions as arguments. Python provides support for them too. Some of the examples of higher order functions are map(), reduce(), filter() etc.</p>
    <p><span>Example</span></p>
    <pre><code># higher order function
    def combine_values(func, values):
        current = values[0]
        for i in range(1, len(values)):
            current = func(current, values[i])
        return current
    
    # addition
    def add(x, y):
        return x + y
    
    # multiplication
    def mul(x, y):
        return x*y
    
    # adds all the values in the list
    print(combine_values(add, [1,2,3,4] ))
    
    # multiplies all the elements in the list
    print(combine_values(mul, [1,2,3,4] ))
    </code></pre>
    <p><span>Output</span> 10</p>
    <p>20</p>
    <h3 id="map-reduce-and-filter">map, reduce and filter</h3>
    <p>Python has many popular higher-order functions like <code>map(), reduce(), filter()</code>. Let’s look at one example from each of them:</p>
    <p><strong>Map Function</strong></p>
    <p><code>map(function, sequence)</code> calls <code>function(item)</code> for each of the sequence’s items and returns a list of the returned values.</p>
    <p><span>Example of map() function</span></p>
    <pre><code># function to square numbers
    def square(x):
        return x**2
    # map function
    mapped = list(map(square, [1,2,3,4]))
    print(mapped)
    </code></pre>
    <p><span>Output</span> [1, 4, 9, 16]</p>
    <p><strong>filter</strong></p>
    <p>filter(function, sequence) returns a sequence consisting of those items from the sequence for which function(item) is true.</p>
    <p><span>Example of filter()</span></p>
    <pre><code># function to check if number is positive
    def positive(x):
        return x &gt; 0
    
    # filter function
    filtered = list(filter(positive, [-3,-2,-1,1,2,3,]))
    print(filtered)
    </code></pre>
    <p><strong>reduce()</strong></p>
    <p>reduce(function, sequence) takes an iterable of input data and consumes it to come up with a single value.</p>
    <p><span>Example of reduce()</span></p>
    <pre><code># import reduce
    from functools import reduce
    
    # function to divide two numbers
    def add(x,y):
        return x + y
    
    # reduce function
    reduced = reduce(add, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])
    print(reduced)
    </code></pre>
    <p><span>Output</span> ’abc’</p>
    <p><span>Task: Fill out even elements</span></p>
    <pre><code># Code starts here
    # natural numbers from 1 to 20
    natural_nums = []
    for i in range(1,21):
        natural_nums.append(i)
    # lambda function for even numbers
    is_even = lambda x : x%2==0  
    # filter() to filter out even elements
    filtered = list(filter(is_even , natural_nums))
    print(filtered)
    # Code ends here
    </code></pre>
    <h2 id="comprehensions">Comprehensions</h2>
    <p>By now, you are already familiar with existing data structures in Python like lists, tuples, dictionaries, etc. All of them need a significant amount of time and code length to create until now.</p>
    <p>But they can be created in a much shorter format which is more time-efficient as well as readable. They are called comprehensions.</p>
    <p>Depending on the type of brackets you use, they may be called:</p>
    <pre><code>•	[ ] as list comprehension
    •	( ) as generator expressions
    •	{ } for dictionary and set comprehensions
    </code></pre>
    <p>The syntax for comprehensions remains the same irrespective of the type of bracket we chose and is given below</p>
    <p><code>[expression(iterator) for iterator in iterable if condition]</code></p>
    <p>You can also use nested for loops with multiple conditions in order to create comprehension.</p>
    <p><span>Example</span></p>
    <pre><code>def even_addition(values):
        evens = [i for i in values if not i%2]
        return sum(evens) 
    
    print(even_addition([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]))
    </code></pre>
    <p><span>Output</span> 42</p>
    <p><span>Task: Present in one but absent in another</span></p>
    <pre><code># Code starts here
    # initialize both lists
    alist = [i for i in range(1,51)]
    blist = [2,3,5,7,11,13,17,19,23,29,31,41,43,47]
    # final list
    final = [i for i in alist if i not in blist]
    # display final list
    print(final)
    # Code ends here
    </code></pre>
    <p><span>Output</span> [1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 42, 44, 45, 46, 48, 49, 50]</p>
    <h2 id="object-oriented-programming-in-nutshell">Object Oriented Programming in Nutshell</h2>
    <p>Till now we have dealt with functions manipulating data inside them which is also called the procedure-oriented way of programming. But there is another more powerful way of organizing your program which gives you the flexibility to deal with data and functionality and wrap it inside something called an object. Since Python is a multi-paradigm language, it supports object-oriented programming (OOP).</p>
    <p>Class and objects are two important aspects in OOP. Class creates a new type altogether whereas object is an instance of an a class. These can have their own attributes i.e. characteristics and methods i.e. actions.</p>
    <p><strong>Example of OOP</strong></p>
    <p>For instance, John is an object of the class human with attributes like name, age and methods like speaking, eating etc.</p>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;"><strong>Property</strong></th>
    <th style="text-align: left;"><strong>Description</strong></th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">Inheritence</td>
    <td style="text-align: left;">A process of using details from a new class without modifying existing class</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">Encapsulation</td>
    <td style="text-align: left;">Hiding the private details of a class from other objects</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">Polymorphism</td>
    <td style="text-align: left;">A concept of using common operation in different ways for different data input</td>
    </tr>
    </tbody>
    </table>
    <h3 id="properties-of-oop">Properties of OOP</h3>
    <p>Like any other language, in Python, the concept of OOP follows some basic principles:</p>
    <p><span>Creating our own class</span></p>
    <pre><code>class Person(object):
    
        # initialize
        def __init__(self, name, title, gender):
            self.name = name
            self.title = title
            self.gender = gender
    
        # display full name
        def display_name(self):
            return self.name + &#39; &#39; + self.title
    
        # display gender
        def isgender(self):
            return self.gender
    
        # change first name
        def change_first_name(self, new_name):
            self.name = new_name
    
        # change title
        def change_title(self, new_title):
            self.title = new_title
    
    # object name &quot;p&quot;
    p = Person(&#39;Rita&#39;, &#39;Roy&#39;, &#39;female&#39;)
    
    # display full name
    print(p.display_name())
    print(&#39;=&#39;*50)
    
    # display gender
    print(p.isgender())
    print(&#39;=&#39;*50)
    
    # change first name
    p.change_first_name(&#39;Amrita&#39;)
    
    # change title
    p.change_title(&#39;Ganguly&#39;)
    
    # print full name
    print(p.display_name())
    </code></pre>
    <p><span>Output</span></p>
    <pre><code>&#39;Rita Roy&#39;
    &#39;==================================================&#39;
    &#39;female&#39;
    &#39;==================================================&#39;
    &#39;Amrita Ganguly&#39;</code></pre>
    <p>Here,</p>
    <ul>
    <li><p>The object part in parentheses specifies the parent class that you are inheriting from.</p></li>
    <li><p>There is an init() method defined with def which instantiates the object for the class. This method takes the self as an argument always. self is nothing but the object itself.</p></li>
    <li><p>The attributes name, title and gender are instance attributes since for every instance they will be different. Remember that only for class attributes it/they will be the same for every instance. We initialize the first name, title, and gender with self.name=name, self.title=title and self.gender=gender</p></li>
    <li><p>display_full_name() is a method which returns the full name of the object.</p></li>
    <li><p>isgender() full name is a method that returns the gender of the object.</p></li>
    <li><p>The method change_first_name() takes in a new_name as argument and modifies the original name.</p></li>
    <li><p>The method change_title() takes in a new_title as argument and modifies the original title.</p></li>
    <li><p>p is an instance of the object Person class with its arguments as Rita, Roy and female.</p></li>
    <li><p>Now, if we do p.display_first_name(), we can see that the full name is displayed i.e. ’Rita Roy’.</p></li>
    <li><p>Now change the first name to ’Amrita’ with .change_first_name() and change the title to ’Ganguly’ with .change_title().</p></li>
    <li><p>If you see the new fill name with p.display_name() then you can see that ’Rita Roy’ has changed to ’Amrita Ganguly’.</p></li>
    </ul>
    <h1 id="introduction-to-matplotlib-in-python">Introduction to Matplotlib in Python</h1>
    <h2 id="what-is-data-visualization">What is data visualization? </h2>
    <p>Data visualization is the practice of visualizing data in graphs, icons, presentations and more. It is most commonly used to translate complex data into digestible insights for a non-technical audience.</p>
    <h2 id="what-is-matplotlib">What is Matplotlib? </h2>
    <p>There are thousands of libraries in Python, and Matplotlib is one of the most powerful tools for data visualization in Python.</p>
    <p>Matplotlib tries to make easy things easy and hard things possible. You can generate plots, histograms, power spectra, bar charts, errorcharts, scatterplots, etc., with just a few lines of code.</p>
    <h3 id="importing-the-library">Importing the library </h3>
    <p>To get matplotlib up and running in our environment, we need to import it.</p>
    <p>import matplotlib.pyplot as plt</p>
    <p>We import matplotlib under alias plt to reduce code duplication many times.</p>
    <p>Whenever we plot with matplotlib, the two main code lines should be,</p>
    <dl>
    <dt>Type of graph</dt>
    <dd><p>this is where you define a bar chart, line chart, etc.</p>
    </dd>
    <dt>Show the graph</dt>
    <dd><p>this is to display graph.</p>
    </dd>
    </dl>
    <h4 id="line-graphs">Line Graphs</h4>
    <p><span>Line Graph</span></p>
    <pre><code>import matplotlib.pyplot as plt
    x_values = [i for i in range(10)]
    squares = [i**2 for i in range(10)]
    
    x_values = x_values+[i for i in range(10,50)]
    squares = squares+[i**2 for i in range(10,50)]
    plt.plot(x_values, squares)
    plt.xlabel(&#39;x_values&#39;)
    plt.ylabel(&#39;y_values&#39;)
    plt.title(&#39;My Graph&#39;)
    # plt.yticks([20,40,60,80],[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;])
    # plt.xticks([1,2,3,4,5,6,7,8,9])
    plt.show()</code></pre>
    <p><img src="./img/linegraph" alt="image" style="height:8cm" /></p>
    <h4 id="bar-graphs">Bar graphs</h4>
    <p><span>Bar Graph</span></p>
    <pre><code>a_values = [4,3,11,9,15,21]
    b_values = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;]
    plt.bar(b_values,a_values,color = &#39;green&#39;)
    plt.show()</code></pre>
    <p><img src="./img/bargraph" alt="image" style="height:8cm" /></p>
    <p>When using bargraph, the change in code will be from <code>plt.plot()</code> to <code>plt.bar()</code>. It changes it into a bar graph. We have also added an argument <code>color</code> to customize the color of the graph.</p>
    <p>We can also flip the bar graph horizontally–</p>
    <p><span>Flipped bar graph</span></p>
    <pre><code>plt.barh(b_values,a_values,color = &#39;yellowgreen&#39;)
    plt.show()</code></pre>
    <p><img src="./img/fbargraph" alt="image" style="height:8cm" /></p>
    <h4 id="scatter-plots">Scatter Plots</h4>
    <p><span>Scatter Plot</span></p>
    <pre><code>plt.scatter(x_values,squares,s=10,color=&#39;red&#39;)
    plt.show()</code></pre>
    <p><img src="./img/scatter" alt="image" style="height:8cm" /></p>
    <p>Now the code changed from <code>plt.bar(</code>) to <code>plt.scatter()</code>. I also added the s argument. The s stands for size, and it allows us to control how big we want the points on the graph.</p>
    <h4 id="histograms">Histograms</h4>
    <p><span>Histogram</span></p>
    <pre><code>from numpy import random
    #Creating random data for plotting
    x=random.randint(100, size=20)
    plt.hist(x,bins=15,color=&#39;blue&#39;,alpha=.5)
    plt.show()</code></pre>
    <p><img src="./img/histogram" alt="image" style="height:8cm" /></p>
    <p>There are two new arguments in the code of histogram–</p>
    <dl>
    <dt>Bins</dt>
    <dd><p>–is an argument to costumize how many bins of histogram we want.</p>
    </dd>
    <dt>Alpha</dt>
    <dd><p>–is an argument that displays the level of transparency of data points.</p>
    </dd>
    </dl>
    <h1 id="introduction-to-numpy">Introduction to Numpy</h1>
    <h2 id="introduction-2">Introduction</h2>
    <h3 id="what-is-numpy">What is Numpy</h3>
    <p>NumPy is a python library used for working with arrays.</p>
    <p>It also has functions for working in domain of linear algebra, fourier transform, and matrices.</p>
    <p>NumPy was created in 2005 by Travis Oliphant. It is an open source project and you can use it freely.</p>
    <p>NumPy stands for Numerical Python.</p>
    <h3 id="why-use-numpy">Why Use NumPy ?</h3>
    <p>In Python we have lists that serve the purpose of arrays, but they are slow to process.</p>
    <p>NumPy aims to provide an array object that is up to 50x faster that traditional Python lists.</p>
    <p>The array object in NumPy is called ndarray, it provides a lot of supporting functions that make working with ndarray very easy.</p>
    <p>Arrays are very frequently used in data science, where speed and resources are very important.</p>
    <p><span>Data Science</span> It is a branch of computer science where we study how to store, use and analyze data for deriving information from it.</p>
    <h3 id="why-is-numpy-faster-than-lists">Why is NumPy Faster Than Lists?</h3>
    <p>NumPy arrays are stored at one continuous place in memory unlike lists, so processes can access and manipulate them very efficiently.</p>
    <p>This behavior is called locality of reference in computer science.</p>
    <p>This is the main reason why NumPy is faster than lists. Also it is optimized to work with latest CPU architectures.</p>
    <h3 id="which-language-is-numpy-written-in">Which Language is NumPy written in?</h3>
    <p>NumPy is a Python library and is written partially in Python, but most of the parts that require fast computation are written in C or C++.</p>
    <h3 id="where-is-the-numpy-codebase">Where is the NumPy Codebase?</h3>
    <p>The source code for NumPy is located at this github repository https://github.com/numpy/numpy</p>
    <p><span>GitHub</span> It enables many people to work on the same codebase.</p>
    <h2 id="getting-started">Getting Started</h2>
    <h3 id="import-numpy">Import Numpy</h3>
    <p><span>Importing Numpy and making an array</span></p>
    <pre><code>import numpy
    
    arr = numpy.array([1, 2, 3, 4, 5])
    
    print(arr)</code></pre>
    <p><span>Output</span> [1 2 3 4 5]</p>
    <h3 id="numpy-as-np">NumPy as np</h3>
    <p>NumPy is usually imported under the np alias.</p>
    <p><span>alias</span> In Python alias are an alternate name for referring to the same thing.</p>
    <p><span>Creating np alias</span> import numpy as np</p>
    <p>Now the NumPy package can be referred to as np instead of numpy.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5])
    
    print(arr)</code></pre>
    <p><span>Output</span> [1 2 3 4 5]</p>
    <h3 id="checking-numpy-version">Checking NumPy Version</h3>
    <p><span>Using __version__ attribute</span></p>
    <pre><code>import numpy as np
    
    print(np.__version__)
    </code></pre>
    <h2 id="creating-arrays">Creating Arrays</h2>
    <h3 id="create-a-numpy-ndarray-object">Create a NumPy ndarray Object</h3>
    <p><span>We can create a NumPy ndarray object by using the array() function.</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5])
    
    print(arr)
    
    print(type(arr))</code></pre>
    <p><span>type()</span> This built-in Python function tells us the type of the object passed to it. Like in above code it shows that arr is numpy.ndarray type.</p>
    <p>To create an ndarray, we can pass a list, tuple or any array-like object into the array() method, and it will be converted into an ndarray:</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array((1, 2, 3, 4, 5))
    
    print(arr)</code></pre>
    <h3 id="dimensions-in-arrays">Dimensions in Arrays</h3>
    <p>A dimension in arrays is one level of array depth (nested arrays).</p>
    <p><span>nested array</span> these are the arrays that have arrays as their elements.</p>
    <h4 id="d-arrays">0-D Arrays</h4>
    <p>0-D arrays, or Scalars, are the elements in an array. Each value in an array is a 0-D array.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array(42)
    
    print(arr)
    </code></pre>
    <h4 id="d-arrays-1">1-D Arrays</h4>
    <p>An array that has 0-D arrays as its elements is called uni-dimensional or 1-D array.</p>
    <p>These are the most common and basic arrays.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5])
    
    print(arr)</code></pre>
    <h4 id="d-arrays-2">2-D Arrays</h4>
    <p>An array that has 1-D arrays as its elements is called a 2-D array.</p>
    <p>These are often used to represent matrix or 2nd order tensors.</p>
    <p>NumPy has a whole sub module dedicated towards matrix operations called <code>numpy.mat</code></p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1, 2, 3], [4, 5, 6]])
    
    print(arr)
    </code></pre>
    <h4 id="d-arrays-3">3-D arrays</h4>
    <p>An array that has 2-D arrays (matrices) as its elements is called 3-D array.</p>
    <p>These are often used to represent a 3rd order tensor.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[[1, 2, 3], [4, 5, 6]],
     [[1, 2, 3], [4, 5, 6]]])
    
    print(arr)</code></pre>
    <h3 id="check-number-of-dimensions">Check Number of Dimensions?</h3>
    <p>NumPy Arrays provides the <code>ndim</code> attribute that returns an integer that tells us how many dimensions the array have.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    a = np.array(42)
    b = np.array([1, 2, 3, 4, 5])
    c = np.array([[1, 2, 3], [4, 5, 6]])
    d = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])
    
    print(a.ndim)
    print(b.ndim)
    print(c.ndim)
    print(d.ndim)
    </code></pre>
    <p><span>Output</span></p>
    <pre><code>0
    1
    2
    3</code></pre>
    <h2 id="higher-dimensional-arrays">Higher Dimensional Arrays</h2>
    <p>An array can have any number of dimensions.</p>
    <p>When the array is created, you can define the number of dimensions by using the <code>ndmin</code> argument.</p>
    <p><span>Create an array with 5 dimensions and verify that it has 5 dimensions</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4], ndmin=5)
    
    print(arr)
    print(&#39;number of dimensions :&#39;, arr.ndim)</code></pre>
    <p><span>Output</span></p>
    <pre><code>[[[[[1 2 3 4]]]]]
    number of dimensions : 5</code></pre>
    <p>In this array the innermost dimension (5th dim) has 4 elements, the 4th dim has 1 element that is the vector, the 3rd dim has 1 element that is the matrix with the vector, the 2nd dim has 1 element that is 3D array and 1st dim has 1 element that is a 4D array.</p>
    <h2 id="numpy-array-indexing">NumPy Array Indexing</h2>
    <h3 id="access-array-elements">Access Array Elements</h3>
    <p>Array indexing is the same as accessing an array element.</p>
    <p>You can access an array element by referring to its index number.</p>
    <p>The indexes in NumPy arrays start with 0, meaning that the first element has index 0, and the second has index 1 etc.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4])
    
    print(arr[0], arr[1])
    print(arr[2] +arr[3])</code></pre>
    <p><span>Output</span></p>
    <pre><code>1 2
    7</code></pre>
    <h3 id="assess-2-d-arrays">Assess 2-D Arrays</h3>
    <p>To access elements from 2-D arrays we can use comma separated integers representing the dimension and the index of the element.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1,2,3,4,5], [6,7,8,9,10]])
    
    print(&#39;2nd element on 1st dim: &#39;, arr[0, 1])
    print(&#39;5th element on 2nd dim: &#39;, arr[1, 4])</code></pre>
    <p><span>Output</span></p>
    <pre><code>2nd element on 1st dim:  2
    5th element on 2nd dim:  10</code></pre>
    <h3 id="access-3-d-arrays">Access 3-D Arrays</h3>
    <p>To access elements from 3-D arrays we can use comma separated integers representing the dimensions and the index of the element.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9],
     [10, 11, 12]]])
    
    print(arr[0, 1, 2])</code></pre>
    <p><span>Output</span></p>
    <pre><code>6</code></pre>
    <p><span>Explanation of Example</span></p>
    <pre><code>arr[0, 1, 2] prints the value 6.
    
    And this is why:
    
    The first number represents the first dimension,
     which contains two arrays:
    [[1, 2, 3], [4, 5, 6]]
    and:
    [[7, 8, 9], [10, 11, 12]]
    Since we selected 0, we are left with the first array:
    [[1, 2, 3], [4, 5, 6]]
    
    The second number represents the second dimension,
     which also contains two arrays:
    [1, 2, 3]
    and:
    [4, 5, 6]
    Since we selected 1, we are left with the second array:
    [4, 5, 6]
    
    The third number represents the third dimension,
     which contains three values:
    4
    5
    6
    Since we selected 2, we end up with the third value:
    6</code></pre>
    <h3 id="negative-indexing">Negative Indexing</h3>
    <p>Use negative indexing to access an array from the end.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1,2,3,4,5], [6,7,8,9,10]])
    
    print(&#39;Last element from 2nd dim: &#39;, arr[1, -1])
    </code></pre>
    <p><span>Output</span></p>
    <pre><code>Last element from 2nd dim:  10</code></pre>
    <h2 id="numpy-array-slicing">NumPy Array Slicing</h2>
    <h3 id="slicing-arrays">Slicing Arrays</h3>
    <p>Slicing in python means taking elements from one given index to another given index.</p>
    <p>We pass slice instead of index like this: <code>[start:end]</code>.</p>
    <p>We can also define the step, like this: <code>[start:end:step]</code>.</p>
    <p>If we don’t pass start its considered 0</p>
    <p>If we don’t pass end its considered length of array in that dimension</p>
    <p>If we don’t pass step its considered 1</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6, 7])
    
    print(arr[1:5])</code></pre>
    <p><span>Output</span> [2 3 4 5]</p>
    <p><span>Note</span> The result includes the start index, but excludes the end index.</p>
    <p><span>Slice elements from index 4 to the end of the array and thenSlice elements from the beginning to index 4 (not included):</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6, 7])
    
    print(arr[4:])
    print(arr[:4])</code></pre>
    <p><span>Output</span> [5 6 7]</p>
    <p>[1 2 3 4]</p>
    <h3 id="negative-slicing">Negative Slicing</h3>
    <p>Use the minus operator to refer to an index from the end:</p>
    <p><span>Slice from the index 3 from the end to index 1 from the end:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6, 7])
    
    print(arr[-3:-1])</code></pre>
    <h3 id="step">STEP</h3>
    <p>Use the <code>step</code> value to determine the step of the slicing:</p>
    <p><span>Return every other element from index 1 to index 5 and then Return every other element from the entire array:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6, 7])
    
    print(arr[1:5:2])
    print(arr[::2])</code></pre>
    <p><span>Output</span> [2 4]</p>
    <p>[1 3 5 7]</p>
    <h3 id="slicing-2-d-arrays">Slicing 2-D Arrays</h3>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])
    
    print(arr[1, 1:4])
    print(arr[0:2, 2])
    print(arr[0:2, 1:4])</code></pre>
    <p><span>Output</span></p>
    <pre><code>[7 8 9]
    [3 8]
    [[2 3 4]
     [7 8 9]]</code></pre>
    <h2 id="numpy-data-types">NumPy Data Types</h2>
    <h3 id="data-types-in-python-1">Data Types in Python</h3>
    <p>By default Python have these data types:</p>
    <dl>
    <dt>strings</dt>
    <dd><p>– used to represent text data, the text is given under quote marks. eg. "ABCD"</p>
    </dd>
    <dt>integer</dt>
    <dd><p>– used to represent integer numbers. eg. -1, -2, -3</p>
    </dd>
    <dt>float</dt>
    <dd><p>–used to represent real numbers. eg. 1.2, 42.42</p>
    </dd>
    <dt>boolean</dt>
    <dd><p>– used to represent True or False.</p>
    </dd>
    <dt>complex</dt>
    <dd><p>– used to represent a number in complex plain. eg. 1.0 + 2.0j, 1.5 + 2.5j</p>
    </dd>
    </dl>
    <h3 id="data-types-in-numpy">Data Types in NumPy</h3>
    <p>NumPy has some extra data types, and refer to data types with one character, like i for integers, u for unsigned integers etc.</p>
    <p>Below is a list of all data types in NumPy and the characters used to represent them.</p>
    <dl>
    <dt>i</dt>
    <dd><p>– integer</p>
    </dd>
    <dt>b</dt>
    <dd><p>– boolean</p>
    </dd>
    <dt>u</dt>
    <dd><p>– unsigned integer</p>
    </dd>
    <dt>f</dt>
    <dd><p>– float</p>
    </dd>
    <dt>c</dt>
    <dd><p>– complex float</p>
    </dd>
    <dt>m</dt>
    <dd><p>– timedelta</p>
    </dd>
    <dt>M</dt>
    <dd><p>– datetime</p>
    </dd>
    <dt>O</dt>
    <dd><p>– object</p>
    </dd>
    <dt>S</dt>
    <dd><p>– string</p>
    </dd>
    <dt>U</dt>
    <dd><p>– unicode string</p>
    </dd>
    <dt>V</dt>
    <dd><p>– fixed chunk of memory for other type ( void )</p>
    </dd>
    </dl>
    <h3 id="checking-the-data-type-of-an-array">Checking the Data Type of an Array</h3>
    <p>The NumPy array object has a property called <code>dtype</code> that returns the data type of the array:</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4])
    
    print(arr.dtype)
    
    arr = np.array([&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;])
    
    print(arr.dtype)</code></pre>
    <p><span>Output</span></p>
    <pre><code>int32
    &lt;U6</code></pre>
    <h3 id="creating-arrays-with-a-defined-data-type">Creating Arrays With a Defined Data Type</h3>
    <p>We use the <code>array()</code> function to create arrays, this function can take an optional argument: <code>dtype</code> that allows us to define the expected data type of the array elements:</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4], dtype=&#39;S&#39;)
    
    print(arr)
    print(arr.dtype)</code></pre>
    <p><span>Output</span></p>
    <pre><code>[b&#39;1&#39; b&#39;2&#39; b&#39;3&#39; b&#39;4&#39;]
    |S1</code></pre>
    <p>For <code>i, u, f, S</code> and <code>U</code> we can define size as well.</p>
    <p><span>Create an array with data type 4 bytes integer:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4], dtype=&#39;i4&#39;)
    
    print(arr)
    print(arr.dtype)</code></pre>
    <h3 id="what-if-a-value-can-not-be-converted">What if a Value Can Not Be Converted?</h3>
    <p>If a type is given in which elements can’t be casted then NumPy will raise a ValueError.</p>
    <p><span>ValueError</span> If a type is given in which elements can’t be casted then NumPy will raise a ValueError.</p>
    <p><span>A non integer string like ’a’ can not be converted to integer (will raise an error):</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([&#39;a&#39;, &#39;2&#39;, &#39;3&#39;], dtype=&#39;i&#39;)</code></pre>
    <p><span>Output</span></p>
    <pre><code>---------------------------------------------------------
    ValueError           Traceback (most recent call last)
    &lt;ipython-input-28-3d3a7c165e54&gt; in &lt;module&gt;
          1 import numpy as np
          2 
    ----&gt; 3 arr = np.array([&#39;a&#39;, &#39;2&#39;, &#39;3&#39;], dtype=&#39;i&#39;)
    
    ValueError: invalid literal for int() with base 10: &#39;a&#39;</code></pre>
    <h3 id="converting-data-type-on-existing-arrays">Converting Data Type on Existing Arrays</h3>
    <p>The best way to change the data type of an existing array, is to make a copy of the array with the <code>astype()</code> method.</p>
    <p>The <code>astype()</code> function creates a copy of the array, and allows you to specify the data type as a parameter.</p>
    <p>The data type can be specified using a string, like <code>’f’</code> for float, <code>’i’</code> for integer etc. or you can use the data type directly like <code>float</code> for float and <code>int</code> for integer.</p>
    <p><span>Change data type from float to integer by using ’i’ as parameter value:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1.1, 2.1, 3.1])
    
    newarr = arr.astype(&#39;i&#39;)
    
    print(newarr)
    print(newarr.dtype)</code></pre>
    <p><span>Output</span></p>
    <pre><code>[1 2 3]
    int32</code></pre>
    <p><span>Change data type from float to integer by using <code>int</code> as parameter value:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1.1, 2.1, 3.1])
    
    newarr = arr.astype(int)
    
    print(newarr)
    print(newarr.dtype)</code></pre>
    <p><span>Output</span></p>
    <pre><code>[1 2 3]
    int32</code></pre>
    <p><span>Change data type from integer to boolean:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 0, 3])
    
    newarr = arr.astype(bool)
    
    print(newarr)
    print(newarr.dtype)</code></pre>
    <p><span>Output</span></p>
    <pre><code>[ True False  True]
    bool</code></pre>
    <h2 id="numpy-array-copy-vs-view">NumPy Array Copy vs View</h2>
    <h3 id="the-difference-between-copy-and-view">The Difference Between Copy and View </h3>
    <p>The main difference between a copy and a view of an array is that the copy is a new array, and the view is just a view of the original array.</p>
    <p>The copy owns the data and any changes made to the copy will not affect original array, and any changes made to the original array will not affect the copy.</p>
    <p>The view does not own the data and any changes made to the view will affect the original array, and any changes made to the original array will affect the view.</p>
    <h3 id="copy">COPY:</h3>
    <p><span>Make a copy change the original array and display both arrays</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5])
    x = arr.copy()
    arr[0] = 42
    
    print(arr)
    print(x)</code></pre>
    <p><span>Output</span></p>
    <pre><code>[42  2  3  4  5]
    [1 2 3 4 5]</code></pre>
    <p>The copy SHOULD NOT be affected by the changes made to the original array.</p>
    <h3 id="view">VIEW:</h3>
    <p><span>Make a view change the original array and display both arrays:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5])
    x = arr.view()
    arr[0] = 42
    
    print(arr)
    print(x)</code></pre>
    <p><span>Output</span></p>
    <pre><code>[42  2  3  4  5]
    [42  2  3  4  5]</code></pre>
    <p>The view SHOULD be affected by the changes made to the original array.</p>
    <h3 id="make-changes-in-the-view">Make Changes in the VIEW:</h3>
    <p><span>Make a view change the view and display both arrays:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5])
    x = arr.view()
    x[0] = 31
    
    print(arr)
    print(x)</code></pre>
    <p><span>Output</span></p>
    <pre><code>[31  2  3  4  5]
    [31  2  3  4  5]</code></pre>
    <p>The original array SHOULD be affected by the changes made to the view.</p>
    <h3 id="check-if-array-owns-its-data">Check if Array Owns it’s Data</h3>
    <p>As mentioned above, copies owns the data, and views does not own the data, but how can we check this?</p>
    <p>Every NumPy array has the attribute <code>base</code> that returns <code>None</code> if the array owns the data.</p>
    <p>Otherwise, the <code>base</code> attribute refers to the original object.</p>
    <p><span>Print the value of the base attribute to check if an array owns it’s data or not:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5])
    
    x = arr.copy()
    y = arr.view()
    
    print(x.base)
    print(y.base)</code></pre>
    <p><span>Output</span></p>
    <pre><code>None
    [1 2 3 4 5]</code></pre>
    <p>The copy returns <code>None</code>. The view returns the original array.</p>
    <h2 id="numpy-array-shape">NumPy Array Shape</h2>
    <h3 id="shape-of-an-array">Shape of an Array</h3>
    <p>The shape of an array is the number of elements in each dimension.</p>
    <p>NumPy arrays have an attribute called <code>shape</code> that returns a tuple with each index having the number of corresponding elements.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
    
    print(arr.shape)</code></pre>
    <p>The example above returns <code>(2, 4)</code>, which means that the array has 2 dimensions, and each dimension has 4 elements.</p>
    <h5 id="exercise">Exercise</h5>
    <p>Create an array with 5 dimensions using <code>ndmin</code> using a vector with values 1,2,3,4 and verify that last dimension has value 4:</p>
    <p><span>Code</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4], ndmin=5)
    
    print(arr)
    print(&#39;shape of array :&#39;, arr.shape)</code></pre>
    <p><span>Output</span></p>
    <pre><code>[[[[[1 2 3 4]]]]]
    shape of array : (1, 1, 1, 1, 4)</code></pre>
    <h3 id="what-does-the-shape-tuple-represent">What does the shape tuple represent?</h3>
    <p>Integers at every index tells about the number of elements the corresponding dimension has.</p>
    <p>In the example above at index-4 we have value 4, so we can say that 5th (4 + 1 th) dimension has 4 elements.</p>
    <h2 id="numpy-array-reshaping">NumPy Array Reshaping</h2>
    <h3 id="reshaping-arrays">Reshaping arrays</h3>
    <p>Reshaping means changing the shape of an array.</p>
    <p>The shape of an array is the number of elements in each dimension.</p>
    <p>By reshaping we can add or remove dimensions or change number of elements in each dimension.</p>
    <h3 id="reshape-from-1-d-to-2-d">Reshape From 1-D to 2-D</h3>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
    
    newarr = arr.reshape(4, 3)
    
    print(newarr)</code></pre>
    <h3 id="reshape-from-1-d-to-3-d">Reshape From 1-D to 3-D</h3>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])
    
    newarr = arr.reshape(2, 3, 2)
    
    print(newarr)</code></pre>
    <h3 id="can-we-reshape-into-any-shape">Can We Reshape Into any Shape?</h3>
    <p>Yes, as long as the elements required for reshaping are equal in both shapes.</p>
    <p>We can reshape an 8 elements 1D array into 4 elements in 2 rows 2D array but we cannot reshape it into a 3 elements 3 rows 2D array as that would require 3x3 = 9 elements.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
    
    newarr = arr.reshape(3, 3)
    
    print(newarr)</code></pre>
    <p><span>Output</span></p>
    <pre><code>Traceback (most recent call last):
      File &quot;demo_numpy_array_reshape_error.py&quot;, line 5, in &lt;module&gt;
    ValueError: cannot reshape array of size 8 into shape (3,3)</code></pre>
    <h3 id="returns-copy-or-view">Returns Copy or View</h3>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
    
    print(arr.reshape(2, 4).base)</code></pre>
    <p>The example above returns the original array, so it is a view.</p>
    <h3 id="unknown-dimension">Unknown Dimension</h3>
    <p>You are allowed to have one "unknown" dimension.</p>
    <p>Meaning that you do not have to specify an exact number for one of the dimensions in the reshape method.</p>
    <p>Pass -1 as the value, and NumPy will calculate this number for you.</p>
    <p><span>Example<br />
    Convert 1D array with 8 elements to 3D array with 2x2 elements:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
    
    newarr = arr.reshape(2, 2, -1)
    
    print(newarr)</code></pre>
    <p><span>Note</span> We can not pass -1 to more than one dimension.</p>
    <h3 id="flattening-the-arrays">Flattening the arrays</h3>
    <p>Flattening array means converting a multidimensional array into a 1D array.</p>
    <p>We can use <code>reshape(-1)</code> to do this.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1, 2, 3], [4, 5, 6]])
    
    newarr = arr.reshape(-1)
    
    print(newarr)
    </code></pre>
    <p><span>Note</span> There are a lot of functions for changing the shapes of arrays in numpy <code>flatten, ravel</code> and also for rearranging the elements <code>rot90, flip, fliplr, flipud</code> etc. These fall under Intermediate to Advanced section of numpy.</p>
    <h2 id="numpy-array-iterating">NumPy Array Iterating</h2>
    <h3 id="iterating-arrays">Iterating Arrays</h3>
    <p>Iterating means going through elements one by one.</p>
    <p>As we deal with multi-dimensional arrays in numpy, we can do this using basic for loop of python.</p>
    <p>If we iterate on a 1-D array it will go through each element one by one.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3])
    
    for x in arr:
      print(x)</code></pre>
    <h3 id="iterating-2-d-arrays">Iterating 2-D Arrays</h3>
    <p>In a 2-D array it will go through all the rows.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1, 2, 3], [4, 5, 6]])
    
    for x in arr:
      print(x)</code></pre>
    <p><span>Note</span> If we iterate on a n-D array it will go through n-1th dimension one by one.</p>
    <p>To return the actual values, the scalars, we have to iterate the arrays in each dimension.</p>
    <p><span>Example<br />
    Iterate on each scalar element of the 2-D array:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1, 2, 3], [4, 5, 6]])
    
    for x in arr:
      for y in x:
        print(y)</code></pre>
    <h3 id="iterating-3-d-arrays">Iterating 3-D Arrays</h3>
    <p>In a 3-D array it will go through all the 2-D arrays.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9],
     [10, 11, 12]]])
    
    for x in arr:
      print(&quot;x represents the 2-D array:&quot;)
      print(x)</code></pre>
    <p><span>Output</span></p>
    <pre><code>x represents the 2-D array:
    [[1 2 3]
     [4 5 6]]
    x represents the 2-D array:
    [[ 7  8  9]
     [10 11 12]]</code></pre>
    <p>To return the actual values, the scalars, we have to iterate the arrays in each dimension.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9],
     [10, 11, 12]]])
    
    for x in arr:
      for y in x:
        for z in y:
          print(z)</code></pre>
    <p><span>Output</span></p>
    <pre><code>1
    2
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12</code></pre>
    <h3 id="iterating-arrays-using-nditer">Iterating Arrays Using nditer()</h3>
    <p>The function <code>nditer()</code> is a helping function that can be used from very basic to very advanced iterations. It solves some basic issues which we face in iteration, lets go through it with examples.</p>
    <h4 id="iterating-on-each-scalar-element">Iterating on Each Scalar Element</h4>
    <p>In basic <code>for</code> loops, iterating through each scalar of an array we need to use n <code>for</code> loops which can be difficult to write for arrays with very high dimensionality.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
    
    for x in np.nditer(arr):
      print(x)
    </code></pre>
    <h3 id="iterating-array-with-different-data-types">Iterating Array With Different Data Types</h3>
    <p>We can use <code>op_dtypes</code> argument and pass it the expected datatype to change the datatype of elements while iterating.</p>
    <p>NumPy does not change the data type of the element in-place (where the element is in array) so it needs some other space to perform this action, that extra space is called buffer, and in order to enable it in <code>nditer()</code> we pass flags=<code>[’buffered’].</code></p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3])
    
    for x in np.nditer(arr, flags=[&#39;buffered&#39;], op_dtypes=[&#39;S&#39;]):
      print(x)</code></pre>
    <h3 id="iterating-with-different-step-size">Iterating With Different Step Size</h3>
    <p>We can use filtering and followed by iteration.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
    
    for x in np.nditer(arr[:, ::2]):
      print(x)</code></pre>
    <h3 id="enumerated-iteration-using-ndenumerate">Enumerated Iteration Using ndenumerate()</h3>
    <p>Enumeration means mentioning sequence number of somethings one by one.</p>
    <p>Sometimes we require corresponding index of the element while iterating, the ndenumerate() method can be used for those usecases.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3])
    
    for idx, x in np.ndenumerate(arr):
      print(idx, x)</code></pre>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
    
    for idx, x in np.ndenumerate(arr):
      print(idx, x)</code></pre>
    <h2 id="numpy-joining-array">NumPy Joining Array</h2>
    <h3 id="joining-numpy-arrays">Joining NumPy Arrays</h3>
    <p>Joining means putting contents of two or more arrays in a single array.</p>
    <p>In SQL we join tables based on a key, whereas in NumPy we join arrays by axes.</p>
    <p>We pass a sequence of arrays that we want to join to the <code>concatenate()</code> function, along with the axis. If axis is not explicitly passed, it is taken as 0</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr1 = np.array([1, 2, 3])
    
    arr2 = np.array([4, 5, 6])
    
    arr = np.concatenate((arr1, arr2))
    
    print(arr)</code></pre>
    <p><span>Output</span></p>
    <pre><code>[1 2 3 4 5 6]</code></pre>
    <p><span>Join two 2-D arrays along rows (axis=1):</span></p>
    <pre><code>import numpy as np
    
    arr1 = np.array([[1, 2], [3, 4]])
    
    arr2 = np.array([[5, 6], [7, 8]])
    
    arr = np.concatenate((arr1, arr2), axis=1)
    
    print(arr)</code></pre>
    <p><span>Example</span></p>
    <pre><code>[[1 2 5 6]
     [3 4 7 8]]</code></pre>
    <h3 id="joining-arrays-using-stack-functions">Joining Arrays Using Stack Functions</h3>
    <p>Stacking is same as concatenation, the only difference is that stacking is done along a new axis.</p>
    <p>We can concatenate two 1-D arrays along the second axis which would result in putting them one over the other, ie. stacking.</p>
    <p>We pass a sequence of arrays that we want to join to the <code>stack()</code> method along with the axis. If axis is not explicitly passed it is taken as 0.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr1 = np.array([1, 2, 3])
    
    arr2 = np.array([4, 5, 6])
    
    arr = np.stack((arr1, arr2), axis=1)
    
    print(arr)
    </code></pre>
    <h3 id="stacking-along-rows">Stacking Along Rows</h3>
    <p>NumPy provides a helper function: <code>hstack()</code> to stack along rows.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr1 = np.array([1, 2, 3])
    
    arr2 = np.array([4, 5, 6])
    
    arr = np.hstack((arr1, arr2))
    
    print(arr)</code></pre>
    <h3 id="stacking-along-columns">Stacking Along Columns</h3>
    <p>NumPy provides a helper function: <code>vstack()</code> to stack along columns.</p>
    <p><span>Example</span></p>
    <pre><code>
    import numpy as np
    
    arr1 = np.array([1, 2, 3])
    
    arr2 = np.array([4, 5, 6])
    
    arr = np.vstack((arr1, arr2))
    
    print(arr)</code></pre>
    <h3 id="stacking-along-height-depth">Stacking Along Height (depth)</h3>
    <p>NumPy provides a helper function: dstack() to stack along height, which is the same as depth.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr1 = np.array([1, 2, 3])
    
    arr2 = np.array([4, 5, 6])
    
    arr = np.dstack((arr1, arr2))
    
    print(arr)</code></pre>
    <h2 id="numpy-splitting-array">NumPy Splitting Array</h2>
    <h3 id="splitting-numpy-arrays">Splitting NumPy Arrays</h3>
    <p>Splitting is reverse operation of Joining.</p>
    <p>Joining merges multiple arrays into one and Splitting breaks one array into multiple.</p>
    <p>We use <code>array_split()</code> for splitting arrays, we pass it the array we want to split and the number of splits.</p>
    <p><span>Example<br />
    Split the array in 3 parts:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6])
    
    newarr = np.array_split(arr, 3)
    
    print(newarr)</code></pre>
    <p><span>Note</span> The return value is an array containing three arrays.</p>
    <p>If the array has less elements than required, it will adjust from the end accordingly.</p>
    <p><span>Example<br />
    Split the array in 4 parts:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6])
    
    newarr = np.array_split(arr, 4)
    
    print(newarr)</code></pre>
    <p><span>Note</span> We also have the method <code>split()</code> available but it will not adjust the elements when elements are less in source array for splitting like in example above, <code>array_split()</code> worked properly but <code>split()</code> would fail.</p>
    <h3 id="split-into-arrays">Split Into Arrays</h3>
    <p>The return value of the <code>array_split()</code> method is an array containing each of the split as an array.</p>
    <p>If you split an array into 3 arrays, you can access them from the result just like any array element:</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6])
    
    newarr = np.array_split(arr, 3)
    
    print(newarr[0])
    print(newarr[1])
    print(newarr[2])</code></pre>
    <h3 id="splitting-2-d-arrays">Splitting 2-D Arrays</h3>
    <p>Use the same syntax when splitting 2-D arrays.</p>
    <p>Use the <code>array_split()</code> method, pass in the array you want to split and the number of splits you want to do.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1, 2], [3, 4], [5, 6], [7, 8],
     [9, 10], [11, 12]])
    
    newarr = np.array_split(arr, 3)
    
    print(newarr)
    </code></pre>
    <p>The example above returns three 2-D arrays.</p>
    <p>In addition, you can specify which axis you want to do the split around.</p>
    <p>The example below also returns three 2-D arrays, but they are split along the row (axis=1).</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12],
     [13, 14, 15], [16, 17, 18]])
    
    newarr = np.array_split(arr, 3, axis=1)
    
    print(newarr)</code></pre>
    <p>An alternate solution is using <code>hsplit()</code> opposite of <code>hstack()</code></p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12],
     [13, 14, 15], [16, 17, 18]])
    
    newarr = np.hsplit(arr, 3)
    
    print(newarr)
    </code></pre>
    <p><span>Note</span> Similar alternates to <code>vstack()</code> and <code>dstack()</code> are available as <code>vsplit()</code> and <code>dsplit()</code>.</p>
    <h2 id="numpy-searching-arrays">NumPy Searching Arrays</h2>
    <h3 id="searching-arrays">Searching Arrays</h3>
    <p>You can search an array for a certain value, and return the indexes that get a match.</p>
    <p>To search an array, use the <code>where()</code> method.</p>
    <p><span>Example<br />
    Find the indexes where the value is 4:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 4, 4])
    
    x = np.where(arr == 4)
    
    print(x)</code></pre>
    <p>The example above will return a tuple: (array([3, 5, 6],)</p>
    <p>Which means that the value 4 is present at index 3, 5, and 6.</p>
    <p><span>Example<br />
    Find the indexes where the values are even:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 2, 3, 4, 5, 6, 7, 8])
    
    x = np.where(arr\%2 == 0)
    
    print(x)</code></pre>
    <h3 id="search-sorted">Search Sorted</h3>
    <p>There is a method called <code>searchsorted()</code> which performs a binary search in the array, and returns the index where the specified value would be inserted to maintain the search order.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([6, 7, 8, 9])
    
    x = np.searchsorted(arr, 7)
    
    print(x)</code></pre>
    <p>Example explained: The number 7 should be inserted on index 1 to remain the sort order.</p>
    <p>The method starts the search from the left and returns the first index where the number 7 is no longer larger than the next value.</p>
    <h4 id="search-from-the-right-side">Search From the Right Side</h4>
    <p>By default the left most index is returned, but we can give <code>side=’right’</code> to return the right most index instead.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([6, 7, 8, 9])
    
    x = np.searchsorted(arr, 7, side=&#39;right&#39;)
    
    print(x)</code></pre>
    <p>Example explained: The number 7 should be inserted on index 2 to remain the sort order.</p>
    <p>The method starts the search from the right and returns the first index where the number 7 is no longer less than the next value.</p>
    <h4 id="multiple-values">Multiple Values</h4>
    <p>To search for more than one value, use an array with the specified values.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([1, 3, 5, 7])
    
    x = np.searchsorted(arr, [2, 4, 6])
    
    print(x)</code></pre>
    <p>The return value is an array: [1 2 3] containing the three indexes where 2, 4, 6 would be inserted in the original array to maintain the order.</p>
    <h2 id="numpy-sorting-arrays">NumPy Sorting Arrays</h2>
    <h3 id="sorting-arrays">Sorting Arrays</h3>
    <p>Sorting means putting elements in an ordered sequence.</p>
    <p>Ordered sequence is any sequence that has an order corresponding to elements, like numeric or alphabetical, ascending or descending.</p>
    <p>The NumPy ndarray object has a function called <code>sort()</code>, that will sort a specified array.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([3, 2, 0, 1])
    
    print(np.sort(arr))</code></pre>
    <p><span>Note</span> This method returns a copy of the array, leaving the original array unchanged.</p>
    <p>You can also sort arrays of strings, or any other data type:</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([&#39;banana&#39;, &#39;cherry&#39;, &#39;apple&#39;])
    
    print(np.sort(arr))</code></pre>
    <h3 id="sorting-a-2-d-array">Sorting a 2-D Array</h3>
    <p>If you use the sort() method on a 2-D array, both arrays will be sorted:</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([[3, 2, 4], [5, 0, 1]])
    
    print(np.sort(arr))</code></pre>
    <h2 id="numpy-filter-array">NumPy Filter Array</h2>
    <h3 id="filtering-arrays">Filtering Arrays</h3>
    <p>Getting some elements out of an existing array and creating a new array out of them is called filtering.</p>
    <p>In NumPy, you filter an array using a boolean index list.</p>
    <p>A boolean index list is a list of booleans corresponding to indexes in the array.</p>
    <p>If the value at an index is <code>True</code> that element is contained in the filtered array, if the value at that index is <code>False</code> that element is excluded from the filtered array.</p>
    <p><span>Example</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([41, 42, 43, 44])
    
    x = [True, False, True, False]
    
    newarr = arr[x]
    
    print(newarr)</code></pre>
    <p>The example above will return [41, 43], why?</p>
    <p>Because the new filter contains only the values where the filter array had the value <code>True</code>, in this case, index 0 and 2.</p>
    <h3 id="creating-the-filter-array">Creating the Filter Array</h3>
    <p>In the example above we hard-coded the <code>True</code> and <code>False</code> values, but the common use is to create a filter array based on conditions.</p>
    <p><span>Example<br />
    Create a filter array that will return only values higher than 42:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([41, 42, 43, 44])
    
    # Create an empty list
    filter_arr = []
    
    # go through each element in arr
    for element in arr:
      # if the element is higher than 42, set the value to True,
        #otherwise False:
      if element &gt; 42:
        filter_arr.append(True)
      else:
        filter_arr.append(False)
    
    newarr = arr[filter_arr]
    
    print(filter_arr)
    print(newarr)</code></pre>
    <h3 id="creating-filter-directly-from-array">Creating Filter Directly From Array</h3>
    <p>The above example is quite a common task in NumPy and NumPy provides a nice way to tackle it.</p>
    <p>We can directly substitute the array instead of the iterable variable in our condition and it will work just as we expect it to.</p>
    <p><span>Example<br />
    Create a filter array that will return only values higher than 42:</span></p>
    <pre><code>import numpy as np
    
    arr = np.array([41, 42, 43, 44])
    
    filter_arr = arr &gt; 42
    
    newarr = arr[filter_arr]
    
    print(filter_arr)
    print(newarr)</code></pre>
    <h1 id="random-numbers-in-numpy">Random Numbers in NumPy</h1>
    <h2 id="what-is-a-random-number">What is a Random Number?</h2>
    <p>Random number does NOT mean a different number every time. Random means something that can not be predicted logically.</p>
    <h3 id="pseudo-random-and-true-random.">Pseudo Random and True Random.</h3>
    <p>Computers work on programs, and programs are definitive set of instructions. So it means there must be some algorithm to generate a random number as well.</p>
    <p>If there is a program to generate random number it can be predicted, thus it is not truly random.</p>
    <p>Random numbers generated through a generation algorithm are called pseudo random.</p>
    <p>Can we make truly random numbers?</p>
    <p>Yes. In order to generate a truly random number on our computers we need to get the random data from some outside source. This outside source is generally our keystrokes, mouse movements, data on network etc.</p>
    <p>We do not need truly random numbers, unless its related to security (e.g. encryption keys) or the basis of application is the randomness (e.g. Digital roulette wheels).</p>
    <h3 id="generate-random-number">Generate Random Number</h3>
    <p>NumPy offers the <code>random</code> module to work with random numbers.</p>
    <p><span>Example</span></p>
    <pre><code>from numpy import random
    
    x = random.randint(100)
    
    print(x)</code></pre>
    <h3 id="generate-random-float">Generate Random Float</h3>
    <p>The random module’s <code>rand()</code> method returns a random float between 0 and 1.</p>
    <p><span>Example</span></p>
    <pre><code>from numpy import random
    
    x = random.rand()
    
    print(x)</code></pre>
    <h3 id="generate-random-array">Generate Random Array</h3>
    <p>In NumPy we work with arrays, and you can use the two methods from the above examples to make random arrays.</p>
    <h4 id="integers">Integers</h4>
    <p>The <code>randint()</code> method takes a size parameter where you can specify the shape of an array.</p>
    <p><span>Example<br />
    Generate a 1-D array containing 5 random integers from 0 to 100:</span></p>
    <pre><code>from numpy import random
    
    x=random.randint(100, size=(5))
    
    print(x)</code></pre>
    <p><span>Example<br />
    Generate a 2-D array with 3 rows each row containing 5 random integers from 0 to 100:</span></p>
    <pre><code>from numpy import random
    
    x = random.randint(100, size=(3, 5))
    
    print(x)</code></pre>
    <h4 id="floats">Floats</h4>
    <p>The <code>rand()</code> method also allows you to specify the shape of the array.</p>
    <p><span>Example<br />
    Generate a 2-D array with 3 rows each row containing 5 random numbers:</span></p>
    <pre><code>from numpy import random
    
    x = random.rand(3, 5)
    
    print(x)
    </code></pre>
    <h3 id="generate-random-number-from-array">Generate Random Number From Array</h3>
    <p>The <code>choice()</code> method allows you to generate a random value based on an array of values.</p>
    <p>The <code>choice()</code> method takes an array as a parameter and randomly returns one of the values.</p>
    <p><span>Example</span></p>
    <pre><code>from numpy import random
    
    x = random.choice([3, 5, 7, 9])
    
    print(x)</code></pre>
    <p>The <code>choice()</code> method also allows you to return an array of values.</p>
    <p>Add a size parameter to specify the shape of the array.</p>
    <p><span>Example</span></p>
    <pre><code>from numpy import random
    
    x = random.choice([3, 5, 7, 9], size=(3, 5))
    
    print(x)</code></pre>
    <h2 id="random-data-distribution">Random Data Distribution</h2>
    <h3 id="what-is-data-distribution">What is Data Distribution?</h3>
    <p>Data Distribution is a list of all possible values, and how often each value occurs.</p>
    <p>Such lists are important when working with statistics and data science.</p>
    <p>The random module offer methods that returns randomly generated data distributions.</p>
    <h3 id="random-distribution">Random Distribution</h3>
    <p>A random distribution is a set of random numbers that follow a certain probability density function.</p>
    <p><span>Probability Density Function</span> A function that describes a continuous probability. i.e. probability of all values in an array.</p>
    <p>We can generate random numbers based on defined probabilities using the <code>choice()</code> method of the random module.</p>
    <p>The <code>choice()</code> method allows us to specify the probability for each value.</p>
    <p>The probability is set by a number between 0 and 1, where 0 means that the value will never occur and 1 means that the value will always occur.</p>
    <h4 id="example">Example</h4>
    <p>Generate a 1-D array containing 100 values, where each value has to be 3, 5, 7 or 9.</p>
    <p>The probability for the value to be 3 is set to be 0.1</p>
    <p>The probability for the value to be 5 is set to be 0.3</p>
    <p>The probability for the value to be 7 is set to be 0.6</p>
    <p>The probability for the value to be 9 is set to be 0</p>
    <p><span>Code</span></p>
    <pre><code>from numpy import random
    
    x = random.choice([3, 5, 7, 9], p=[0.1, 0.3, 0.6, 0.0],
     size=(100))
    
    print(x)</code></pre>
    <p><span>Output</span> [7 7 7 7 7 5 5 7 3 5 5 7 7 7 5 5 5 7 7 3 7 5 7 7 5 7 5 7 7 7 7 7 5 7 5 7 5 7 5 7 7 3 5 5 7 7 7 7 5 5 7 7 7 7 5 7 7 7 7 7 7 5 7 7 7 7 5 5 7 5 3 5 7 3 7 5 7 7 7 5 7 3 7 7 5 5 7 7 5 5 7 5 5 5 3 7 7 5 3 5]</p>
    <p>Even if you run the example above 100 times, the value 9 will never occur.</p>
    <p>You can return arrays of any shape and size by specifying the shape in the size parameter.</p>
    <p><span>Example</span></p>
    <pre><code>from numpy import random
    
    x = random.choice([3, 5, 7, 9], p=[0.1, 0.3, 0.6, 0.0], size=(3, 5))
    
    print(x)</code></pre>
    <p><span>Output</span></p>
    <pre><code>[[7 5 7 7 7]
     [5 7 7 7 7]
     [5 3 5 5 7]]</code></pre> -->
    </li>
    
    <li>
        <h2><a href="/2021/01/09/python3.html">Python Notes Topic 3</a></h2>
        <!--     </div>
    <h1 id="creating-a-tuple">Creating a Tuple</h1>
    <p>Tuples are another type similar to lists. They store values of any type separated by commas. But how do they differ from lists?</p>
    <ul>
    <li><p>Firstly, they start and end with parenthesis ().</p>
    <p>For example</p>
    <p><code>(1,2,3,4)</code></p></li>
    <li><p>But the main difference that <strong>unlike lists, tuples are immutable i.e., they cannot be updated/changed</strong>. You can think of them as <strong>read only lists</strong>.</p></li>
    </ul>
    <p>As discussed above, it should begin and end with parenthesis.</p>
    <p>Takin the same example of weights from our discussion on lists</p>
    <p><code>scores = (80,90,95,100)</code> The only difference is that we cannot change the values inside it.</p>
    <h2 id="common-tuple-operations">Common tuple operations</h2>
    <p>Let us take two tuples a = (1,2) and b = (3,4) for this purpose</p>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;">Expession</th>
    <th style="text-align: center;">Description</th>
    <th style="text-align: center;">Example</th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">len(a)</td>
    <td style="text-align: center;">Length of tuple</td>
    <td style="text-align: center;">2</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">a + b</td>
    <td style="text-align: center;">Concatenation</td>
    <td style="text-align: center;">(1,2,3,4)</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">a*4</td>
    <td style="text-align: center;">Repitition</td>
    <td style="text-align: center;">(1,2,1,2,1,2,1,2)</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">2 in a</td>
    <td style="text-align: center;">Membership</td>
    <td style="text-align: center;">True</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">max(a)</td>
    <td style="text-align: center;">Maximum value in tuple</td>
    <td style="text-align: center;">2</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">min(a)</td>
    <td style="text-align: center;">Minimum value in tuple 1</td>
    <td style="text-align: center;"></td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">a[0]</td>
    <td style="text-align: center;">Indexing</td>
    <td style="text-align: center;">1</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">a[:2]</td>
    <td style="text-align: center;">Slicing</td>
    <td style="text-align: center;">(1,2)</td>
    </tr>
    </tbody>
    </table>
    <p>We cannot delete an element from the tuple(as they are immutable), but we can delete the entire tuple.</p>
    <p># <span style="color: gray">create tuple tuple of weights</span></p>
    <p>weights = (70, 80, 45, 50)</p>
    <p># <span style="color: gray">code starts here</span></p>
    <p># <span style="color: gray">create new tuple of weights</span></p>
    <p>weights_new = (70, 80, 45,50)</p>
    <p># <span style="color: gray">calculate maximum and minimum weights</span></p>
    <p>maximum = max(weights_new)</p>
    <p>minimum = min(weights_new)</p>
    <p># <span style="color: gray">calculate sum of weights</span></p>
    <p>sum_weights = sum(weights_new)</p>
    <p>l = len(weights_new)</p>
    <p># <span style="color: gray">calculate mean</span></p>
    <p>mean_new = sum_weights/l</p>
    <p>print(maximum, minimum, sum_weights, mean_new)</p>
    <p># <span style="color: gray">code ends here</span></p>
    <h1 id="mutable-vs-immutable">Mutable vs immutable</h1>
    <h2 id="introduction">Introduction</h2>
    <p>We have been hearing about <strong>mutable</strong> and <strong>immutable</strong> all along. Simply put, objects which can be modified after creation in the same memory location are called <strong>mutable</strong> and the others which cannot, are termed <strong>immutable</strong>.</p>
    <p><strong>Immutable objects</strong>: int, float, long, complex, string, tuple, bool <strong>Mutable objects</strong>: list, dict, set, byte, array, user defined classes.</p>
    <h2 id="checking-mutability">Checking Mutability</h2>
    <p>We can check if an object is mutable by first modifying the object and then comparing its new memory location with the old memory location. We can check for memory location either by using the <code>id()</code> function, which gives us memory location of the object or with the help of <code>is</code> operator, which checks for the identity of two objects.</p>
    <p>First let’s take an integer (type <code>int</code>) 50 and add 1 to it with the same variable name, then check its memory location before and after the modification, with <code>id()</code> function. As it turns out, both have different memory locations, and hence it is an immutable type.</p>
    <p># <span style="color: gray">initial variable</span></p>
    <p>a = 50</p>
    <p># <span style="color: gray">initial memory location</span></p>
    <p>print(id(a))</p>
    <p># <span style="color: gray">modified variable</span></p>
    <p>a += 1</p>
    <p># <span style="color: gray">new memory location, is it same?</span></p>
    <p>print(id(a))</p>
    <p><strong>Output</strong></p>
    <p>94285850046496</p>
    <p>94285850046528</p>
    <p>Now let’s make a list with values [1,2,3,4] and add 5 to it with <code>.append()</code>. You observe that after modification, it still refers to the same memory location as before, and hence it is of mutable type.</p>
    <p># <span style="color: gray">initial list</span></p>
    <p>l = [1,2,3,4]</p>
    <p># <span style="color: gray">initial memory location</span></p>
    <p>print(id(l))</p>
    <p>print(’=’*20)</p>
    <p># <span style="color: gray">new list</span></p>
    <p>l.append(5)</p>
    <p>print(l)</p>
    <p>print(’=’*20)</p>
    <p># <span style="color: gray">new memory location</span></p>
    <p>print(id(l))</p>
    <p><strong>Output</strong></p>
    <p>2083508003264</p>
    <p>====================</p>
    <p>[1, 2, 3, 4, 5]</p>
    <p>====================</p>
    <p>2083508003264</p>
    <h1 id="what-are-operators">What are Operators?</h1>
    <h2 id="introduction-1">Introduction</h2>
    <p>Operators are special symbols in Python that carry out arithmatic or logical computation. The values that the operator operates on is called operand.</p>
    <p>For example,</p>
    <p>In the <code>3 + 3 = 6</code> operation, the numbers on the left-hand side of the = sign, i.e., 3 and 3 are operands while + is the operator and 6 is the output of the operation.</p>
    <h2 id="types-of-operators">Types of operators</h2>
    <p>Python supports the following types of operators —</p>
    <ul>
    <li><p>Arithmatic Operators</p></li>
    <li><p>Comparison (Relational) Operators</p></li>
    <li><p>Logical Operators</p></li>
    <li><p>Assignment Operators</p></li>
    <li><p>Bitwise Operators</p></li>
    <li><p>Membership Operators</p></li>
    <li><p>Identity Operators</p></li>
    </ul> -->
    </li>
    
    <li>
        <h2><a href="/2021/01/09/python2.html">Python Notes Topic 2</a></h2>
        <!--     </div>
    <h1 id="create-your-own-variable">Create Your Own Variable</h1>
    <p>In this task, you will assign names to variable and also check their types.</p>
    <ul>
    <li><p>Assign value of <code>12</code> to a new variable <code>‘age’</code> and John to <code>‘name’</code>.</p></li>
    <li><p>Save the type of age using <code>type(age)</code> and save it to a variable <code>type_age</code>.</p></li>
    <li><p>Similarly save the type of name to a variable <code>type_name</code></p></li>
    <li><p>Print out the variables <code>type_age</code> and <code>type_name</code> using print() function.</p></li>
    </ul>
    <h2 id="test-cases">Test Cases</h2>
    <p>The variable <code>‘age’</code> should be int with value <span class="math inline">\(12\)</span>. The variable <code>‘name’</code> should be string with value <code>‘John’</code>, i.e.,</p>
    <ul>
    <li><p>type(age) == int</p></li>
    <li><p>age == 12</p></li>
    <li><p>type(name) == str</p></li>
    <li><p>name == “John”</p></li>
    </ul>
    <p># Code Starts Here<br />
    # Assign variables name<br />
    age = 12<br />
    name = ‘John’<br />
    # check types<br />
    type_name = type(name)<br />
    type_age = type(age)<br />
    # print out types<br />
    print(type_name)<br />
    print(type_age)<br />
    # Code ends here<br />
    </p>
    <h1 id="numbers">Numbers</h1>
    <h2 id="numeric-types">Numeric Types</h2>
    <p>It is used to store values.<br />
    For Example:</p>
    <p>x = 5<br />
    y = 10<br />
    balance = 15000<br />
    etc</p>
    <p>Python supports three different types of numbers, listed as follows:</p>
    <ul>
    <li><p>int (integers)</p></li>
    <li><p>float (decimal numbers)</p></li>
    <li><p>complex (complex numbers)</p></li>
    </ul>
    <h3 id="integers">Integers</h3>
    <p>Integers are positive and negative whole numbers with no decimal point.</p>
    <p>For Example:</p>
    <p>2 and 4 are integers</p>
    <h3 id="float">Float</h3>
    <p>Floats are the numbers containing a decimal point.</p>
    <p>For Example:</p>
    <p>2.3</p>
    <p>Note that the numbers written in a scientific notation such as <span class="math inline">\(2.5*10^5\)</span> are considered as float number because they contain a decimal point in notation.</p>
    <h3 id="complex-numbers">Complex numbers</h3>
    <p>Python also provides support to complex numbers of the form <span class="math inline">\(a+bj\)</span> where a and b are floats and j is equals to <span class="math inline">\(\sqrt{-1}\)</span>.</p>
    <h1 id="common-numeric-operations">Common Numeric Operations</h1>
    <table>
    <thead>
    <tr class="header">
    <th style="text-align: center;"><strong>Symbol</strong></th>
    <th style="text-align: center;"><strong>Function</strong></th>
    <th style="text-align: center;"><strong>Example</strong></th>
    </tr>
    </thead>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">+</td>
    <td style="text-align: center;">Addition</td>
    <td style="text-align: center;"><span class="math inline">\(2+3\)</span></td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">-</td>
    <td style="text-align: center;">Subtraction</td>
    <td style="text-align: center;"><span class="math inline">\(2-3\)</span></td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">*</td>
    <td style="text-align: center;">Multiplication</td>
    <td style="text-align: center;"><span class="math inline">\(2*3\)</span></td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">//</td>
    <td style="text-align: center;">Integer division (returns quotient only)</td>
    <td style="text-align: center;"><span class="math inline">\(3/3\)</span></td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">/</td>
    <td style="text-align: center;">division</td>
    <td style="text-align: center;"><span class="math inline">\(3/2\)</span></td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">**</td>
    <td style="text-align: center;">Exponantiation</td>
    <td style="text-align: center;"><span class="math inline">\(2^3\)</span></td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">abs(x)</td>
    <td style="text-align: center;">Absolute value</td>
    <td style="text-align: center;"><span class="math inline">\(\|x\|\)</span></td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">exp(x)</td>
    <td style="text-align: center;">Exponantial x</td>
    <td style="text-align: center;"><span class="math inline">\(e^x\)</span></td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">log(x)</td>
    <td style="text-align: center;">Logarithm with base e</td>
    <td style="text-align: center;"><span class="math inline">\(log_ex\)</span></td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">log10(x)</td>
    <td style="text-align: center;">Logarithm with base 10</td>
    <td style="text-align: center;"><span class="math inline">\(log_{10}x\)</span></td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">pow(x,y)</td>
    <td style="text-align: center;">x raised to power y</td>
    <td style="text-align: center;"><span class="math inline">\(x^y\)</span></td>
    </tr>
    </tbody>
    </table>
    <h1 id="type-conversion">Type Conversion</h1>
    <p>During data manipulation, there might arise a need for converting an integer to float, float to an integer, float to a string or a string (having a number) to an integer or float. Lets look at how we can do this.</p>
    <p>Let’s say we have a number ‘x’. The following some operations can be done:</p>
    <ul>
    <li><p><code>int(x)</code> converts it to an integer.</p></li>
    <li><p><code>float(x)</code> converts it to a float.</p></li>
    <li><p><code>complex(x)</code> converts it to a complex number with real part x and imaginary part 0.</p></li>
    <li><p>We can convert an integer, a float or a complex to a string by <code>str(x)</code>.</p></li>
    </ul>
    <h2 id="calculate-the-compound-interest">Calculate the compound interest</h2>
    <p>In this problem, you will calculate the compound interest. Remember that the formula for compound interest for the amount ‘A’ after ‘n’ years is <span class="math display">\[A = P \left(1 + \frac{r}{100} \right) ^n\]</span> Here, A is the amount after n years, r is the rate of interest per annum, and P is the principal.</p>
    <p>Our task is to calculate the amount after two years when principal amount is USD 1000 at a rate of 10% per annum.</p>
    <h3 id="instructions">Instructions</h3>
    <ul>
    <li><p>Save principal, rate of interest and time in variables p, r and n respectively.</p></li>
    <li><p>Now calculate the amount according to formula given above and save it in a variable A.</p></li>
    <li><p>Calculate interest by formula <span class="math inline">\(A-P\)</span> and store it in variable Interest.</p></li>
    <li><p>Print out interest using print() function.</p></li>
    </ul>
    <p># Code Starts Here<br />
    # Store variable names<br />
    p = 1000<br />
    r = 10<br />
    n = 2<br />
    # Amount formula<br />
    A = p*(1+10/100)**2<br />
    # Display Amount<br />
    print(A)<br />
    # Calculate and display interest<br />
    interest = A-P print(interest)</p>
    <p># Code ends here</p>
    <h1 id="string">String</h1>
    <p>Strings can be written in three ways:</p>
    <ul>
    <li><p>Single quotes.</p>
    <p>Example:</p>
    <p><code>name = ‘Ajeet’</code></p></li>
    <li><p>Double quotes</p>
    <p>Example:</p>
    <p><code>name = “Ajeet”</code></p></li>
    <li><p>Triple quotes: They are used as multi line comment and also used to make docstrings of a defined function.</p>
    <p>Example:</p>
    <p><code>“‘This is a function. Do not change it, or else it will not work.’”</code></p></li>
    </ul>
    <p>We can use Python’s built in len() function to find the length of string.</p>
    <h2 id="slicing-and-indexing-of-strings">Slicing and Indexing of Strings</h2>
    <p>Indexing means giving every character of string a unique value. Indexing in Python starts from zero, that means first letter of string has a value zero (not 1). All the iterables (String, dictionaries, tuples, sets) have this property.</p>
    <table>
    <tbody>
    <tr class="odd">
    <td style="text-align: center;">0</td>
    <td style="text-align: center;">1</td>
    <td style="text-align: center;">2</td>
    <td style="text-align: center;">3</td>
    <td style="text-align: center;">4</td>
    <td style="text-align: center;">5</td>
    <td style="text-align: center;">6</td>
    <td style="text-align: center;">7</td>
    <td style="text-align: center;">8</td>
    <td style="text-align: center;">9</td>
    <td style="text-align: center;">10</td>
    <td style="text-align: center;">11</td>
    </tr>
    <tr class="even">
    <td style="text-align: center;">M</td>
    <td style="text-align: center;">O</td>
    <td style="text-align: center;">N</td>
    <td style="text-align: center;">T</td>
    <td style="text-align: center;">Y</td>
    <td style="text-align: center;"></td>
    <td style="text-align: center;">P</td>
    <td style="text-align: center;">Y</td>
    <td style="text-align: center;">T</td>
    <td style="text-align: center;">H</td>
    <td style="text-align: center;">O</td>
    <td style="text-align: center;">N</td>
    </tr>
    <tr class="odd">
    <td style="text-align: center;">-12</td>
    <td style="text-align: center;">-11</td>
    <td style="text-align: center;">-10</td>
    <td style="text-align: center;">-9</td>
    <td style="text-align: center;">-8</td>
    <td style="text-align: center;">-7</td>
    <td style="text-align: center;">-6</td>
    <td style="text-align: center;">-5</td>
    <td style="text-align: center;">-4</td>
    <td style="text-align: center;">-4</td>
    <td style="text-align: center;">-3</td>
    <td style="text-align: center;">-1</td>
    </tr>
    </tbody>
    </table>
    <p>In the above image, for the string “Monty Python”, the following points can be noticed.</p>
    <ul>
    <li><p>From left to right, index goes from 0 to (length of string - 1).</p></li>
    <li><p>From right to left, index goes from -(length of string) to -1.</p></li>
    <li><p>Ommiting term before or after the colon (:) means including everything from starting or till the end, respectively.</p></li>
    </ul>
    <p>The syntex for slicing in Python, in general, is <strong>[Start index(included):Stop index(excluded)]</strong></p>
    <p>In the above example:</p>
    <p>if we assign variable</p>
    <p>name = “Monty Python”</p>
    <p>then:</p>
    <ul>
    <li><p><code>name[6:10]</code> returns <code>Pyth</code></p></li>
    <li><p><code>name[-12:-7]</code> returns <code>Monty</code></p></li>
    <li><p><code>name[:4]</code> returns <code>Monty</code></p></li>
    <li><p><code>name[6:]</code> returns <code>Python</code></p></li>
    <li><p><code>name[:]</code> returns <code>Monty Python</code></p></li>
    <li><p><code>name[-6:9]</code> returns <code>Pyt</code></p></li>
    </ul> -->
    </li>
    
    <li>
        <h2><a href="/2021/01/09/python1.html">Python Notes Topic 1</a></h2>
        <!--     <h1 id="why-python-for-data-science">Why Python for Data Science?</h1>
    <p>Python was created by Guide Van Rossum and first released in 1991. The name Python was inspired by the comedy series Monty Python’s Flying circus.</p>
    <h2 id="advantages-of-python">Advantages of Python:</h2>
    <p>Following are the some of major advantages of Python:</p>
    <h3 id="easy-to-learn">Easy to learn:</h3>
    <p>Python is a very beginner friendly language. The syntax (words and structure) is extremely simple to read and follow, most of which can be understood even if you do not know programming.</p>
    <h3 id="versatility">Versatility:</h3>
    <p>Python is a multi paradigm programming language. It supports object oriented programming, structured programming and functional programming patterns among others. Python can handle any job ranging from data mining to website construction to running embeded system. It is all in one united language.</p>
    <h3 id="community-support">Community Support:</h3>
    <p>Python’s broad and diverse base means that there are millions of users who are happy to offer advice and suggestions when you get stuck on something. Chances are high that someone else would have been stuck there before you. Open source communities are known for there open discussion policies. In fact most of the queries can be solved by a single google search.</p>
    <h3 id="awesome-free-libraries">Awesome free libraries:</h3>
    <p>The libraries form the backbone for the success of any programming language. At present more than 140,000 projects exists in the Python Package Installer(PyPI). Data Science has been early beneficiary of these libraries like NumPy, Pandas and Scikit learn are extremely popular and widely used by data scientists worldwide. Do you want to start doing Deep learning? No Problem! Python has libraries like Tensorflow, Pytorch and Keras to help you.</p>
    <h3 id="interpreted-language">Interpreted language:</h3>
    <p>Python is an interpreted language, not compiled one. This means that the original program is translated into "something else". Another program "the interpreter" then examines "something else" and performs whatever actions are called for. Besides, Python is dynamically typed, i.e., we don’t need to define variable datatype ahead of time; Python automatically guesses the datatype of variable based on the type of value it contains.</p>
    <h1 id="variables-and-print-statement">Variables and Print Statement</h1>
    <h2 id="what-are-variables">What are Variables?</h2>
    <p>Variables are used to store values in memory. We can store integers, decimals, characters, words or sentences in a variable. In order to define a variable we use equals (=) sign.</p>
    <p>1 0 Paul</p>
    <h1 id="datatypes-in-python">Datatypes in Python</h1>
    <p>Python has five standard data types listed as follows:</p>
    <ol>
    <li><p>Boolean</p></li>
    <li><p>Numbers</p></li>
    <li><p>String</p></li>
    <li><p>Dictionary</p></li>
    <li><p>Tuple</p></li>
    </ol>
    <h2 id="boolean">Boolean</h2>
    <p>Boolean is nothing but True(1) and False(0) statements. Their sole purpose is to evaluate the conditions.</p>
    <p>True True False</p>
    <h3 id="we-will-take-a-look-in-other-datatypes-in-upcoming-topics">We will take a look in other datatypes in upcoming topics</h3>
    <h1 id="how-to-use-print-statement">How to use print statement?</h1>
    <h2 id="the-print-function">The print() function:</h2>
    <p>The print() function is used to display the variable’s result as we have used above.</p>
    <p>The syntax is print(*objects, sep=‘ ’, end=‘\n’, file = sys.stdout, flush=False) Here,<br />
    1. objects is are the values to be displayed.<br />
    2. sep is the separator used between values (default is a space charactor).<br />
    3. After all values are printed, end is printed(default is a new line charactor).<br />
    4. file is the object where the values are printed(default value is sys.stdout i.e. screen).<br />
    5. flush is used to specify if the output has to be flushed (True) or buffered (False). Its default value is False.</p>
    <p>Note: The values given after equals sign are default values, if we do not pass any values then the parameters automatically takes defaut values, otherwise we can give them values of our choice as in the following example.</p>
    <p>Ajeet$Singh Parmarthe end</p>
    <h1 id="determining-the-type-of-object-with-type-function">Determining the type of object with type() function:</h1>
    <p>If you are confused about which class the object belongs to, then simply use the type function.</p>
    <p>&lt;class ’str’&gt;</p>
    <p>The above output says that the variable name belongs to class str, which make sense as name contains ‘Ajeet’ which is obviously a string.</p>
    <h1 id="checking-instance-type-with-instance">Checking Instance type with instance()</h1>
    <p>The instance() function checks if the subject (first argument) is an instance or a subclass of classinfo(second argument). Its syntax is: instance(object, classinfo)</p>
    <p>It returns True if the object is an instance or subclass of the class or any element of tuple, otherwise it returns False.</p>
    <p>True False</p>
    <p>In the next topic, you will get a brief overview of the different datatypes and how to create an object of that datatype alongwith some of its properties. So be excited :)</p> -->
    </li>
    
</ul>



<div class="container mx-auto my-5">
    <form action="https://formspree.io/f/xoqpywjj" method="POST">
      <fieldset>
        <legend>Contact Us</legend>
      <div class="form-group">
        <label for="name">Name</label>
        <input type="text" class="form-control" id="name" name="name" placeholder="Write Your Name">
      </div>
      <div class="form-group">
        <label for="email">Email address</label>
        <input type="email" class="form-control" id="email" name="email" placeholder="name@example.com">
      </div>
      <div class="form-group">
        <label for="message">Message</label>
        <textarea class="form-control" id="message" name="message" rows="3"></textarea>
      </div>
      <div class="m-2">
      <button type="submit" class="btn btn-outline-primary btn-lg btn-block">Send</button>
    </div>
    </fieldset>
    </form>
  </div>



<footer>Website designed by Ajeet Singh Parmar</footer>

<script
  src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js"
  integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW"
  crossorigin="anonymous"
></script>
</body>
</html>